<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NanchtteGachaRollSimulator</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 10px; font-size: 12px; }
        h1 { font-size: 1em; font-weight: bold; text-align: center; margin-bottom: 10px;}
        #controls label, #controls input, #controls button, #controls span { margin-right: 10px; margin-bottom: 10px; display: inline-block; }
        .error { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 4px; text-align: left; }
        th { background-color: #f2f2f2; text-align: center; vertical-align: middle; position: relative; }
        .highlight { background-color: #CCFFCE; } /* Light Green */
        .highlight-uber { background-color: #6EFF72; color: black; } /* Brighter Green */
        .gacha-select-header { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; }
        .gacha-select-header span { margin-left: 5px; font-size: 10px; }
        .gacha-select-header select {
            width: 20px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") no-repeat right / .8em;
            padding-right: 1em;
        }
        .gacha-select-header button { font-size: 10px; padding: 2px 4px; margin-left: 4px; }
        .add-gacha-btn { font-size: 12px; font-weight: normal; padding: 2px 6px; margin-left: 15px; }
        #result { margin-top: 20px; border: 1px solid #ccc; padding: 10px; white-space: pre-wrap; font-family: monospace; background-color: #f9f9f9; max-height: 300px; overflow-y: auto; }
        #table-actions { text-align: center; margin-top: 10px; }
        #table-actions button { margin: 0 5px; }

        /* Toggle visibility classes */
        .hidden { display: none; }
        .seed-column { width: 75px; text-align: center; font-size: 10px; color: #555; }
        .calc-column { width: 80px; text-align: left; font-size: 10px; color: #555; white-space: pre-wrap; word-break: break-all; }
        .gacha-column { width: 160px; }
        .col-no { width: 35px; text-align: center; white-space: nowrap; }
        #toggle-description, #toggle-sim-input, #toggle-seed-input { cursor: pointer; color: blue; text-decoration: underline; margin-bottom: 10px; display: block; text-align: center; }
        #description-content { border: 1px solid #ccc; padding: 10px; margin-top: 10px; margin-bottom: 10px; white-space: pre-wrap; font-size: 11px; }


        @media screen and (max-width: 768px) {
            body {
                padding: 5px;
                -webkit-text-size-adjust: 100%;
            }
            #controls {
                padding: 10px;
            }
            #controls label,
            #controls input,
            #controls button, 
            #controls span {
                display: block;
                width: 95%;
                margin: 0 auto 10px auto;
                box-sizing: border-box;
            }
            #rolls-table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            table {
                width: auto;
                min-width: 800px;
            }
            th, td {
                padding: 4px;
                font-size: 11px;
                line-height: 1.3;
            }
            td.gacha-cell {
                word-break: break-word;
            }
            .gacha-select-header span {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <h1>NanchtteGachaRollSimulator</h1>

    <div id="toggle-description" onclick="toggleDescription()">概要を非表示</div>
    <div id="description-content">概要
このシミュレーターはロールズのルート取り専用に作成したものです。本家のロールズと違い、操作が非常に分かりにくいので、操作方法を簡単に説明します。
（作成者の想定した使い方）
１，SEED欄にシーカー等で調べた開始前SEEDを入力（例）12345
２．表のA列タイトルのガチャ名の左にあるフィルダウンリストから引きたいガチャを選択（例）ウルトラソウルズ、波動バスターズ
なお、他のガチャも引きたい場合は「A」の横の「+列を追加」で追加
３．引きたい順に表の上の方からキャラをタップしていく（例）、11A左：うらしまタロウ、12A右：前田慶次、19A左：きんたろう、（ウルトラソウルズの右の「G」をタップして表示して）25AG左：ももたろう、37B左：花咲かじいさん、・・・
なお、キャラをタップするとそのマスから11連確定等を使わないと到達できないマスはキャラ名をタップしても反応しなくなります
SEED更新ボタンを押すとシミュレーションにより薄緑色等でハイライトされた最後のマスの最終SEEDが反映され、表が更新されます
※機能が少なく、エラーも多いので、少しずつ対応していくつもりです</div>

    <div id="controls">
        <button onclick="updateSeedFromSim()">SEED更新</button>
        <span id="toggle-seed-input" onclick="showSeedInput()">SEED入力</span>
        <div id="seed-controls" class="hidden">
            <label for="seed">SEED:</label>
            <input type="number" id="seed" value="12345" min="1" max="4294967295" onchange="resetAndGenerateTable()">
        </div>
        <span id="toggle-sim-input" onclick="showSimInput()">シミュレーションテキスト入力欄表示</span>
        <div id="simulation-controls" class="hidden">
            <label for="sim-config">シミュレーション:</label>
            <input type="text" id="sim-config" placeholder="ガチャID-ロール数" onchange="resetAndGenerateTable()">
            <button onclick="clearSimConfig()">クリア</button>
        </div>
    </div>

    <div id="rolls-table-container"></div>
    <div id="table-actions">
        <button onclick="addMoreRows(100)">100行追加する</button>
        <button id="toggle-seed-btn" onclick="toggleSeedColumns()">SEEDを表示</button>
        <button id="toggle-result-btn" onclick="toggleResultDisplay()">計算過程を表示</button>
    </div>
    <div id="result"></div>

    <script>
        let gachaMasterData = {};
        const dataFiles = ['data/cats.js', 'data/gacha.js'];
        let tableGachaIds = [];
        let currentRolls = 100;
        let showSeedColumns = false;
        let showResultDisplay = false;
        let finalSeedForUpdate = null; // SEED更新ボタン用

        function toggleDescription() {
            const content = document.getElementById('description-content');
            const toggle = document.getElementById('toggle-description');
            const isHidden = content.classList.toggle('hidden');
            toggle.textContent = isHidden ? '概要を表示' : '概要を非表示';
        }

        function showSimInput() {
            // 'simulation-controls' というIDを持つ要素を取得
            var simControls = document.getElementById('simulation-controls');
            // 'hidden' クラスをトグルする
            simControls.classList.toggle('hidden');
        }

        function showSeedInput() {
            // 'seed-controls' というIDを持つ要素を取得
            var seedControls = document.getElementById('seed-controls');
            // 'hidden' クラスが付いていれば外し、付いていなければ付ける
            seedControls.classList.toggle('hidden');
        }

        function clearSimConfig() {
            document.getElementById('sim-config').value = '';
            resetAndGenerateTable();
        }

        const fallbackCats = [
            {id:31,name:"ネコぼさつ",rarity:3},{id:32,name:"ネコ番長",rarity:3},{id:33,name:"ネコザイル",rarity:3},{id:34,name:"ねこタツ",rarity:3},{id:35,name:"ネコルガ",rarity:4},{id:36,name:"オタネコ",rarity:3},{id:37,name:"ネコスイマー",rarity:3},{id:38,name:"ネコホッピング",rarity:2},{id:39,name:"ネコ車輪",rarity:2},{id:40,name:"ネコリンゴ",rarity:3},{id:41,name:"ネコバスたぶ",rarity:3},{id:42,name:"ネコエステ",rarity:2},{id:43,name:"ネコアイス",rarity:4},{id:44,name:"ネコマシン",rarity:4},{id:45,name:"鬼にゃんま",rarity:4},{id:47,name:"ねこジュラ",rarity:2},{id:48,name:"ねこファイター",rarity:2},{id:49,name:"ねこ海賊",rarity:2},{id:50,name:"ねこ泥棒",rarity:2},{id:51,name:"ねこ僧侶",rarity:2},{id:52,name:"ねこ占い師",rarity:2},{id:53,name:"ネコシャーマン",rarity:2},{id:56,name:"ネコ魔女",rarity:2},{id:57,name:"ネコアーチャー",rarity:2},{id:58,name:"ネコシュバリエ",rarity:4},{id:59,name:"ネコ魔剣士",rarity:2},{id:60,name:"ねこベビー",rarity:4},{id:62,name:"ねこ寿司",rarity:3},{id:76,name:"風神のウィンディ",rarity:4},{id:84,name:"地龍ソドム",rarity:4},{id:85,name:"聖龍メギドラ",rarity:4},{id:107,name:"召し豚のカイ",rarity:4},{id:108,name:"宝杖のカッパーマイン",rarity:4},{id:130,name:"金ネコ",rarity:3},{id:132,name:"ねねこ",rarity:3},{id:136,name:"ツルの恩返し",rarity:4},{id:144,name:"ねこナース",rarity:4},{id:145,name:"にゃんこ城Mini",rarity:3},{id:146,name:"ねこガンマン",rarity:2},{id:147,name:"たけうまねこ",rarity:2},{id:148,name:"ブリキネコ",rarity:2},{id:149,name:"ねこロッカー",rarity:2},{id:150,name:"ねこ人魚",rarity:2},{id:151,name:"窓辺の乙女ネコ",rarity:3},{id:152,name:"ネコバーベル",rarity:3},{id:153,name:"ネコスケート",rarity:3},{id:154,name:"ネコトースター",rarity:3},{id:169,name:"アシルガ",rarity:4},{id:170,name:"クビルガ",rarity:4},{id:171,name:"テコルガ",rarity:4},{id:172,name:"バララガ",rarity:4},{id:197,name:"キャットマンダディ",rarity:4},{id:198,name:"サイキックネコ",rarity:2},{id:199,name:"ねこ陰陽師",rarity:2},{id:200,name:"ネコサーファー",rarity:3},{id:201,name:"メタルネコ",rarity:3},{id:238,name:"おかめはちもくネコ",rarity:3},{id:239,name:"ボンボンネコ",rarity:3},{id:240,name:"見習いスニャイパー",rarity:3},{id:241,name:"トゲルガ",rarity:4},{id:258,name:"天空神ゼウス",rarity:4},{id:259,name:"守護神アヌビス",rarity:4},{id:260,name:"美女神アフロディーテ",rarity:4},{id:272,name:"太陽神アマテラス",rarity:4},{id:273,name:"繁栄神ガネーシャ",rarity:4},{id:287,name:"ももたろう",rarity:4},{id:308,name:"かさじぞう",rarity:4},{id:309,name:"うらしまタロウ",rarity:4},{id:317,name:"きんたろう",rarity:4},{id:326,name:"かぐやひめ",rarity:4},{id:377,name:"花咲かじいさん",rarity:4},{id:378,name:"鶴の恩返し",rarity:4},{id:440,name:"前田慶次",rarity:4},{id:444,name:"織田信長",rarity:4},{id:445,name:"伊達政宗",rarity:4},{id:446,name:"武田信玄",rarity:4},{id:447,name:"上杉謙信",rarity:4},{id:448,name:"真田幸村",rarity:4},{id:494,name:"成田甲斐",rarity:4},{id:496,name:"今川義元",rarity:4},{id:535,name:"猿かに合戦",rarity:4},{id:643,name:"舌切り雀",rarity:4},{id:724,name:"さるかに合戦",rarity:4},{id:812,name:"ちびネコヴァルキリー",rarity:4}
        ];
        const fallbackGacha = [
            {id:992, name:"波動バスターズ", rare:7000, supa:2500, uber:500, sort:1, cats:[812,724,643,535,494,440,317,273,272,260,259,258,448,447,446,445,444,201,145,132,130,238,239,240,524,523,496,378,377,326,308,309,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:452, name:"エアバスターズ", rare:7000, supa:2500, uber:500, sort:2, cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:523, name:"ギガントゼウス", rare:7000, supa:2500, uber:500, sort:3, cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]}
        ];

        async function loadAndProcessData() {
            const loadedData = {};
            try {
                for (const file of dataFiles) {
                    const response = await fetch(file);
                    if (!response.ok) throw new Error('Network response was not ok.');
                    const text = await response.text();
                    const jsonStr = text.substring(text.indexOf('['), text.lastIndexOf(']') + 1);
                    loadedData[file.split('/')[1].split('.')[0]] = JSON.parse(jsonStr);
                }
            } catch (e) {
                console.warn("Failed to load external data, using fallback data.", e);
                loadedData.cats = fallbackCats;
                loadedData.gacha = fallbackGacha;
            }

            const rarityMap = { 0: "nomal", 1: "ex", 2: "rare", 3: "super", 4: "uber", 5: "legend" };
            const catsMaster = {};
            for (const cat of loadedData.cats) { catsMaster[cat.id] = { ...cat, rarity: rarityMap[cat.rarity] || "rare" }; }
            const gachasMaster = {};
            for (const gacha of loadedData.gacha) {
                const pool = { rare: [], super: [], uber: [], legend: [], nomal: [], ex: [] };
                if (gacha.cats) {
                    for (const catId of gacha.cats) {
                        const catInfo = catsMaster[catId];
                        if (catInfo && pool[catInfo.rarity] !== undefined) pool[catInfo.rarity].push({ id: catInfo.id, name: catInfo.name });
                    }
                }
                gachasMaster[gacha.id] = {
                    id: gacha.id.toString(),
                    name: gacha.name || `ガチャID: ${gacha.id}`,
                    rarity_rates: { rare: gacha.rare || 0, super: gacha.supa || 0, uber: gacha.uber || 0, legend: gacha.legend || 0 },
                    pool: pool,
                    sort: gacha.sort
                };
            }
            gachaMasterData = { cats: catsMaster, gachas: gachasMaster };

            const urlParams = new URLSearchParams(window.location.search);
            const seedParam = urlParams.get('seed');
            const simConfigParam = urlParams.get('sim_config');
            const gachasParam = urlParams.get('gachas');

            if (gachasParam) {
                tableGachaIds = gachasParam.split('-');
            } else if (simConfigParam) {
                tableGachaIds = [];
            } else {
                const sortedGachas = Object.values(gachaMasterData.gachas)
                    .filter(gacha => gacha.sort < 800)
                    .sort((a, b) => a.sort - b.sort);
                if (sortedGachas.length > 0) {
                    tableGachaIds.push(sortedGachas[0].id);
                    if (sortedGachas.length > 1) {
                        tableGachaIds.push(sortedGachas[1].id);
                    }
                }
            }

            if (seedParam) {
                document.getElementById('seed').value = seedParam;
                showSeedInput(); // if seed is in URL, show the input
            }
            if (simConfigParam) {
                document.getElementById('sim-config').value = simConfigParam;
                showSimInput(); // if sim_config is in URL, show the input
            }

            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();

            resetAndGenerateTable();
        }
        
        function updateSeedFromSim() {
            if (finalSeedForUpdate) {
                document.getElementById('seed').value = finalSeedForUpdate;
                document.getElementById('sim-config').value = ''; // sim-config をブランクにする
                resetAndGenerateTable(); 
            }
        }

        function addMoreRows(count) {
            currentRolls += count;
            generateRollsTable();
        }

        function resetAndGenerateTable() {
            finalSeedForUpdate = null;
            // sim-config がブランクの場合のみ currentRolls をリセット
            if (document.getElementById('sim-config').value.trim() === '') {
                 currentRolls = 100;
            }
            generateRollsTable();
        }

        function updateGachaSelection(selectElement, index) {
            const originalIdWithG = tableGachaIds[index];
            const isGuaranteed = originalIdWithG.endsWith('g');
            let newId = selectElement.value;
            if (isGuaranteed) {
                newId += 'g';
            }
            tableGachaIds[index] = newId;
            generateRollsTable();
        }

        function addGachaColumn() {
            const sortedGachas = Object.values(gachaMasterData.gachas)
                .filter(gacha => gacha.sort < 800)
                .sort((a, b) => a.sort - b.sort);

            if (sortedGachas.length > 0) {
                tableGachaIds.push(sortedGachas[0].id);
                generateRollsTable();
            }
        }

        function removeGachaColumn(index) {
            tableGachaIds.splice(index, 1);
            generateRollsTable();
        }

        function toggleSeedColumns() {
            showSeedColumns = !showSeedColumns;
            generateRollsTable(); 
            updateToggleButtons();
        }

        function toggleResultDisplay() {
            showResultDisplay = !showResultDisplay;
            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();
        }
        function updateToggleButtons() {
            document.getElementById('toggle-seed-btn').textContent = showSeedColumns ? 'SEEDを非表示' : 'SEEDを表示';
            document.getElementById('toggle-result-btn').textContent = showResultDisplay ? '計算過程を非表示' : '計算過程を表示';
        }

        function updateUrlParams() {
            const seed = document.getElementById('seed').value;
            const simConfig = document.getElementById('sim-config').value;
            const urlParams = new URLSearchParams(window.location.search);

            if (seed) {
                urlParams.set('seed', seed);
            } else {
                urlParams.delete('seed');
            }
            if (simConfig) {
                urlParams.set('sim_config', simConfig);
            } else {
                urlParams.delete('sim_config');
            }
            if (tableGachaIds.length > 0) {
                urlParams.set('gachas', tableGachaIds.join('-'));
            } else {
                urlParams.delete('gachas');
            }

            const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
            // ★ 修正: history.pushState を try...catch で囲む
            try {
                window.history.pushState({path: newUrl}, '', newUrl);
            } catch (e) {
                console.warn("Could not update URL parameters:", e.message);
                // サンドボックス環境 (blob: や iframe) では pushState が失敗することがある
                // アプリの実行を継続するためにエラーを無視する
            }
        }

        class Xorshift32 { constructor(seed) { this.seed = (seed >>> 0) || 1; } next() { let x = this.seed; x ^= (x << 13); x ^= (x >>> 17); x ^= (x << 15); this.seed = x >>> 0; return this.seed; } }

        
        /**
         * 固定シード配列と開始インデックスを用いてガチャを一回実行し、シード消費を含む詳細を返す
         * @param {number} startIndex - seeds配列の開始インデックス
         * @param {object} gachaConfig - ガチャ設定
         * @param {number[]} seeds - 全シード値の配列
         * @param {object} lastDrawInfo - 直前のドロー情報 ({rarity, charId})
         * @returns {object} - ロール結果の詳細
         */
        function rollWithSeedConsumptionFixed(startIndex, gachaConfig, seeds, lastDrawInfo) {
            if (startIndex + 1 >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: null, s1: null, s2: null };
            
            // S0, S1, S2 are seeds[startIndex], seeds[startIndex+1], seeds[startIndex+2]
            const s0_seed = seeds[startIndex];
            const s1_seed = seeds[startIndex + 1];

            // Rarity Roll (based on S0)
            const rarityRoll = s0_seed % 10000;
            const rates = gachaConfig.rarity_rates || {};
            const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
            let currentRarity;
            if (rarityRoll < rareRate) { currentRarity = 'rare'; } else if (rarityRoll < rareRate + superRate) { currentRarity = 'super'; } else if (rarityRoll < rareRate + superRate + uberRate) { currentRarity = 'uber'; } else if (rarityRoll < rareRate + superRate + uberRate + legendRate) { currentRarity = 'legend'; } else { currentRarity = 'rare'; }
            
            const characterPool = gachaConfig.pool[currentRarity] || [];
            if (characterPool.length === 0) {
                // s2_seedも返すように修正 (誘発ロジックが参照するため)
                const s2_seed = (startIndex + 2 < seeds.length) ? seeds[startIndex + 2] : null;
                return { seedsConsumed: 2, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed, s1: s1_seed, s2: s2_seed };
            }
            
            // Character Roll (based on S1)
            const totalChars = characterPool.length;
            const charIndex = s1_seed % totalChars;
            let character = characterPool[charIndex];
            const originalChar = character;
            let seedsConsumed = 2;
            let isRerolled = false;
            let s2_seed = (startIndex + 2 < seeds.length) ? seeds[startIndex + 2] : null; // s2は常に読み込む
            let reRollIndex = null;
            let uniqueTotal = null;

            if (currentRarity === 'rare' && lastDrawInfo && lastDrawInfo.rarity === 'rare' && lastDrawInfo.charId === character.id) {
                // Rare Dupe Check
                const uniqueRareChars = characterPool.filter(c => c.id !== lastDrawInfo.charId);
                uniqueTotal = uniqueRareChars.length;
                
                if (uniqueTotal > 0) {
                    // Reroll is possible (3 seeds consumed)
                    if (s2_seed === null) { // s2 がない場合はデータ不足
                         return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: s0_seed, s1: s1_seed, s2: null };
                    }
                    
                    reRollIndex = s2_seed % uniqueTotal;
                    character = uniqueRareChars[reRollIndex];
                    isRerolled = true;
                    seedsConsumed = 3;
                } 
                // If uniqueTotal == 0, seedsConsumed remains 2, isRerolled remains false (unavoidable dupe).
            }
            
            return { 
                s0: s0_seed, s1: s1_seed, s2: s2_seed, 
                originalChar: originalChar, 
                finalChar: character, 
                isRerolled: isRerolled, 
                rarity: currentRarity, 
                charId: character.id, 
                charIndex: charIndex, 
                totalChars: totalChars, 
                uniqueTotal: uniqueTotal,
                reRollIndex: reRollIndex,
                seedsConsumed: seedsConsumed 
            };
        }

        function rollGuaranteedUber(startIndex, gachaConfig, seeds) {
            if (startIndex >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: 'uber', charId: null, s0: null };

            const s0_seed = seeds[startIndex];
            const currentRarity = 'uber';
            const characterPool = gachaConfig.pool[currentRarity] || [];
            const totalChars = characterPool.length;
            if (totalChars === 0) {
                return { seedsConsumed: 1, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed };
            }
            const charIndex = s0_seed % totalChars;
            const character = characterPool[charIndex];
            return { seedsConsumed: 1, finalChar: character, originalChar: character, isRerolled: false, rarity: currentRarity, charId: character.id, charIndex: charIndex, totalChars: totalChars, s0: s0_seed };
        }


        function calculateGuaranteedLookahead(startSeedIndex, gachaConfig, allSeeds, initialLastDraw) {
            if (!gachaConfig || !gachaConfig.pool['uber']) return { name: "N/A", nextSeed: null, nextRollStartSeedIndex: null };

            let seedCursor = startSeedIndex;
            let lastDraw = initialLastDraw;
            let nextSimSeedValue = null;

            for (let i = 0; i < 10; i++) {
                if (seedCursor + 1 >= allSeeds.length) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };

                const rollResult = rollWithSeedConsumptionFixed(seedCursor, gachaConfig, allSeeds, lastDraw);
                if (rollResult.seedsConsumed === 0) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
                
                seedCursor += rollResult.seedsConsumed;
                lastDraw = { rarity: rollResult.rarity, charId: rollResult.charId };
            }

            if (seedCursor >= allSeeds.length) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
            
            // Guaranteed roll (11th roll is 1-seed roll)
            const guaranteedRollResult = rollGuaranteedUber(seedCursor, gachaConfig, allSeeds);
            if (guaranteedRollResult.seedsConsumed === 0) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
            
            seedCursor += guaranteedRollResult.seedsConsumed;
            
            nextSimSeedValue = (seedCursor < allSeeds.length) ? allSeeds[seedCursor] : null;

            return { name: guaranteedRollResult.finalChar.name, nextSeed: nextSimSeedValue, nextRollStartSeedIndex: seedCursor };
        }

        function toggleGuaranteedColumn(index) {
            const idWithG = tableGachaIds[index];
            if (idWithG.endsWith('g')) {
                tableGachaIds[index] = idWithG.slice(0, -1);
            } else {
                tableGachaIds[index] = idWithG + 'g';
            }
            generateRollsTable();
        }

        // --- sim-config ヘルパー関数 ---
        function parseSimConfig(configStr) {
            if (!configStr) return []; // ★ null や '' の場合、空配列を返す
            const configs = [];
            const parts = configStr.split('-');
            for (let i = 0; i < parts.length; i += 2) {
                const id = parts[i];
                const rollStr = parts[i+1];
                if (id && rollStr) {
                    const isGuaranteed = rollStr.endsWith('g');
                    const rolls = parseInt(rollStr.replace('g', ''), 10);
                    configs.push({ id, rolls, g: isGuaranteed });
                }
            }
            return configs;
        }

        function stringifySimConfig(configArr) {
            return configArr.map(c => `${c.id}-${c.rolls}${c.g ? 'g' : ''}`).join('-');
        }
        
        /**
         * 最後のロール数を+1するか、11gの場合は次のセグメントを追加する (継続リンク用)
         * @param {string} configStr - sim-config文字列
         * @returns {string|null} - 更新されたsim-config文字列
         */
        function incrementLastRoll(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length > 0) {
                const last = configs[configs.length - 1];
                if (!last.g) { 
                    last.rolls += 1;
                } else {
                    // 11gの次は1
                    configs.push({ id: last.id, rolls: 1, g: false });
                }
            }
            return stringifySimConfig(configs);
        }

        /**
         * 最後のロール数を-1するか、ロール数が1の場合は最後のセグメントを削除する (Rule B: 逆算用)
         * @param {string} configStr - sim-config文字列
         * @returns {string|null} - 更新されたsim-config文字列
         */
        function decrementLastRollOrRemoveSegment(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length === 0) return null;

            const last = configs.pop();

            if (last.g) {
                // 確定枠からの逆算の場合 (Rule Aの逆算時)
                if (last.rolls === 11) {
                    last.rolls = 10;
                    last.g = false;
                    configs.push(last);
                }
            } else {
                // 通常抽選からの逆算の場合
                if (last.rolls > 1) {
                    last.rolls -= 1;
                    configs.push(last);
                }
                // last.rolls === 1 の場合、セグメントは削除
            }

            return configs.length > 0 ? stringifySimConfig(configs) : '';
        }

        /**
         * 確定枠のリンクを生成するロジック（隣接セルからの生成） (Rule E/確定枠のリンク設定)
         * @param {string} configStr - 左のセル (通常抽選) のsim-config
         * @param {string} gachaId - 確定枠のガチャID
         * @returns {string|null} - 生成された確定枠のsim-config、またはnull
         */
        function generateGuaranteedConfig(configStr, gachaId) {
            if (!configStr) return null;

            const parsed = parseSimConfig(configStr);
            if (parsed.length === 0) return null;
            
            // リンクは左のセルのパラメータを参照し、最後のロール数を-1して...
            const lastPart = parsed.pop();
            
            // 最後のセグメントが通常ロールであり、かつロール数が1以上であること
            if (!lastPart.g && lastPart.rolls > 0) { 
                
                // 通常抽選のロール数を -1 する
                const newRollsForLastPart = Math.max(0, lastPart.rolls - 1);
                
                // 置き換える部分 (10ロール分) のシミュレーション設定を再追加
                if (newRollsForLastPart > 0) {
                    lastPart.rolls = newRollsForLastPart;
                    parsed.push(lastPart);
                }

                // 続けて当該列のガチャID、11ｇとする
                parsed.push({ id: gachaId, rolls: 11, g: true });
                
                return stringifySimConfig(parsed);
            }
            return null;
        }

        // --- ★ 5. (新規) 回避/誘発ロジック用ヘルパー関数 ---

        /**
         * i行目のトラックの「代表」リンクを取得する (i-1 や i-2 からの参照用)
         * @param {Map} cellSimConfigs - デフォルトリンクのMap
         * @param {string} track - 'A' or 'B'
         * @param {number} i - 行インデックス
         * @param {Array} gachaConfigs - ガチャ設定配列
         * @returns {string|null} - 見つかった最初のsim-config文字列、またはnull
         */
        function getBestLink(cellSimConfigs, track, i, gachaConfigs) {
            if (i < 0) return null;
            for (const config of gachaConfigs) {
                const configStr = cellSimConfigs.get(`${track}-${i}-${config.id}`);
                if (configStr) {
                    return configStr;
                }
            }
            return null;
        }

        /**
         * 誘発ロジック用に、強制的に3シード消費した場合のキャラ名を取得する
         * @param {object} currentRoll - tableData[i][track][gachaIndex].roll の中身
         * @param {object} gachaConfig - ガチャ設定
         * @returns {string|null} - 再抽選後のキャラ名、またはnull
         */
        function getForcedRerollName(currentRoll, gachaConfig) {
            if (!currentRoll || !gachaConfig || currentRoll.rarity !== 'rare' || currentRoll.s2 === null) {
                return null;
            }
            
            const characterPool = gachaConfig.pool['rare'] || [];
            const uniqueRareChars = characterPool.filter(c => c.id !== currentRoll.originalChar.id);
            const uniqueTotal = uniqueRareChars.length;
            
            if (uniqueTotal > 0) {
                const reRollIndex = currentRoll.s2 % uniqueTotal;
                return uniqueRareChars[reRollIndex].name;
            }
            return null;
        }


        /**
         * (メインロジック) レア被り回避と誘発の代替リンクを計算する
         * @param {string} track - 'A' or 'B'
         * @param {number} i - 行インデックス
         * @param {string} currentGachaId - 現在のガチャID
         * @param {Array} tableData - 全テーブルデータ
         * @param {Array} gachaConfigs - ガチャ設定配列
         * @param {Map} cellSimConfigs - デフォルトリンクのMap
         * @param {number} newRow1Index - CONTINUEエリアの開始行
         * @returns {object} - { link: string|null, rerollCharName: string|null }
         */
        function checkAvoidanceAndForcing(track, i, currentGachaId, tableData, gachaConfigs, cellSimConfigs, newRow1Index) {
            // FIXEDエリア (ハイライト) では実行しない
            if (i < newRow1Index) {
                return { link: null, rerollCharName: null };
            }

            const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
            if (gachaIndex === -1 || !tableData[i] || !tableData[i][track][gachaIndex]) {
                return { link: null, rerollCharName: null };
            }

            const currentRoll = tableData[i][track][gachaIndex].roll;
            const isRerolled = currentRoll.isRerolled; // ガチャX単体での判定
            const originalCharId = currentRoll.originalChar?.id; // originalCharがnullの場合がある
            const originalRarity = currentRoll.rarity;

            // レア以外は対象外
            if (originalRarity !== 'rare' || !originalCharId) {
                return { link: null, rerollCharName: null };
            }

            for (const otherConfig of gachaConfigs) {
                const otherGachaId = otherConfig.id;
                if (otherGachaId === currentGachaId) continue; // 自分自身とは比較しない

                const otherIndex = gachaConfigs.findIndex(c => c.id === otherGachaId);
                const otherRoll_i = tableData[i][track][otherIndex].roll;
                const otherRoll_prev = (i > 0) ? tableData[i-1][track][otherIndex].roll : null;

                if (isRerolled) {
                    // --- 1. レア被り回避 (Avoid Dupe) ---
                    // (デフォルトが3-seedなので、2-seedになる代替リンク (avoidConfig) を探す)

                    // A. 直前の行(i-1)に違うキャラ(Y)がいる
                    if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId !== originalCharId) {
                        // [config_i-2] + [Y-1] + [X-1]
                        // 注: 3シード消費 (A->B または B->A) をまたいだ i-2 の参照は複雑すぎるため、
                        // i-1 が2シード消費だった場合の i-2 (同一トラック) のみ考慮する。
                        const prevRoll = (i > 0) ? tableData[i-1][track][gachaIndex].roll : null;
                        if (prevRoll && prevRoll.seedsConsumed <= 2) {
                             const prevPrevConfig = getBestLink(cellSimConfigs, track, i - 2, gachaConfigs);
                             if (prevPrevConfig !== null) {
                                return { link: stringifySimConfig([...parseSimConfig(prevPrevConfig), {id: otherGachaId, rolls: 1, g: false}, {id: currentGachaId, rolls: 1, g: false}]), rerollCharName: null };
                             }
                        }
                    }
                    // B. 当該行(i)に違うキャラ(Y)がいる
                    if (otherRoll_i && otherRoll_i.rarity === 'rare' && otherRoll_i.charId !== originalCharId) {
                        // [config_i-1] + [Y-1]
                        const prevConfig = getBestLink(cellSimConfigs, track, i - 1, gachaConfigs);
                         if (prevConfig !== null) {
                            return { link: stringifySimConfig([...parseSimConfig(prevConfig), {id: otherGachaId, rolls: 1, g: false}]), rerollCharName: null };
                         }
                    }
                } else {
                    // --- 2. レア被り誘発 (Force Dupe) ---
                    // (デフォルトが2-seedなので、3-seedになる代替リンク (forceConfig) を探す)
                    
                    // A. 直前の行(i-1)に同じキャラ(Y)がいる
                    if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                        // [config_i-2] + [Y-1] + [X-1]
                        const prevRoll = (i > 0) ? tableData[i-1][track][gachaIndex].roll : null;
                        if (prevRoll && prevRoll.seedsConsumed <= 2) {
                            const prevPrevConfig = getBestLink(cellSimConfigs, track, i - 2, gachaConfigs);
                            if (prevPrevConfig !== null) {
                                const rerollCharName = getForcedRerollName(currentRoll, gachaConfigs[gachaIndex]);
                                return { link: stringifySimConfig([...parseSimConfig(prevPrevConfig), {id: otherGachaId, rolls: 1, g: false}, {id: currentGachaId, rolls: 1, g: false}]), rerollCharName: rerollCharName };
                            }
                        }
                    }
                    // B. 当該行(i)に直前(X, i-1)と同じキャラ(Y)がいる
                    const prevRoll = (i > 0) ? tableData[i-1][track][gachaIndex].roll : null;
                    if (prevRoll && prevRoll.rarity === 'rare' && otherRoll_i && otherRoll_i.rarity === 'rare' && otherRoll_i.charId === prevRoll.charId) {
                         // [config_i-1] + [Y-1]
                        const prevConfig = getBestLink(cellSimConfigs, track, i - 1, gachaConfigs);
                        if (prevConfig !== null) {
                            const rerollCharName = getForcedRerollName(currentRoll, gachaConfigs[gachaIndex]);
                            return { link: stringifySimConfig([...parseSimConfig(prevConfig), {id: otherGachaId, rolls: 1, g: false}]), rerollCharName: rerollCharName };
                        }
                    }
                }
            }

            return { link: null, rerollCharName: null };
        }

        function canBeForced(track, i, currentGachaId, tableData, gachaConfigs) {
            const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
            if (gachaIndex === -1 || i === 0 || !tableData[i] || !tableData[i][track][gachaIndex]) return false;

            const currentRoll = tableData[i][track][gachaIndex].roll;
            // Must be a non-rerolled rare to be forceable.
            if (currentRoll.rarity !== 'rare' || currentRoll.isRerolled || !currentRoll.originalChar) return false;

            const originalCharId = currentRoll.originalChar.id;

            // To force the reroll, we need to find a path that ends at i-1 with a character
            // that IS originalCharId. We only consider paths on the same track.
            for (const otherConfig of gachaConfigs) {
                const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
                if (otherIndex === -1) continue;

                const otherRoll_prev = tableData[i-1]?.[track]?.[otherIndex]?.roll;

                // If there is any character in the previous row (from any gacha) that is the one that would cause a dupe,
                // it's possible to route through it and force the dupe.
                if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                    return true;
                }
            }

            return false;
        }

        function canBeAvoided(track, i, currentGachaId, tableData, gachaConfigs) {
            const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
            if (gachaIndex === -1 || i === 0 || !tableData[i] || !tableData[i][track][gachaIndex]) return false;

            const currentRoll = tableData[i][track][gachaIndex].roll;
            // Must be a rerolled rare to be avoidable.
            if (currentRoll.rarity !== 'rare' || !currentRoll.isRerolled || !currentRoll.originalChar) return false;
            
            const originalCharId = currentRoll.originalChar.id;

            // To avoid the reroll, we need to find a path that ends at i-1 with a character
            // that is NOT originalCharId. We only consider paths on the same track.
            for (const otherConfig of gachaConfigs) {
                const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
                if (otherIndex === -1) continue;

                const otherRoll_prev = tableData[i-1]?.[track]?.[otherIndex]?.roll;

                // If there is any character in the previous row (from any gacha) that is not the one causing the dupe,
                // it's possible to route through it and avoid the dupe.
                if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId !== originalCharId) {
                    return true;
                }
            }

            return false;
        }

        // --- ヘルパー関数 終了 ---

        // --- Helper functions for new calculation columns ---
        function getRarityDetail(track, rowIndex, rollResult, seeds) {
            if (!rollResult) return '';
            const startIndex = rowIndex * 2 + (track === 'B' ? 1 : 0);
            const { s0, rarity } = rollResult;
            if (s0 === null || rarity === null) return '';
            return `(S${startIndex + 1})${s0}<br>${s0 % 10000}<br>${rarity}`;
        }

        function getSlotDetail(track, rowIndex, rollResult, seeds) {
            if (!rollResult) return '';
            const startIndex = rowIndex * 2 + (track === 'B' ? 1 : 0);
            const { s1, totalChars, charIndex } = rollResult;
            if (s1 === null || totalChars === 0) return '';
            return `(S${startIndex + 2})${s1}<br>${totalChars}<br>${charIndex}`;
        }

        function getRerollDetail(track, rowIndex, rollResult, gachaConfig, seeds) {
            if (rollResult && rollResult.isRerolled) {
                const startIndex = rowIndex * 2 + (track === 'B' ? 1 : 0);
                const { s2, uniqueTotal, reRollIndex } = rollResult;
                if (s2 === null) return '---';
                return `(S${startIndex + 3})${s2}<br>${uniqueTotal}<br>${reRollIndex}`;
            } else {
                return '---';
            }
        }

        function getGuaranteedDetail(track, rowIndex, gachaConfig, seeds, lastDraw) {
            if (!gachaConfig) return '---';
            const startIndex = rowIndex * 2 + (track === 'B' ? 1 : 0);
            const lookahead = calculateGuaranteedLookahead(startIndex, gachaConfig, seeds, lastDraw);

            if (!lookahead || lookahead.name === "データ不足" || lookahead.name === "N/A" || lookahead.nextRollStartSeedIndex === null) {
                return '---';
            }
            
            const guaranteedSeedIndex = lookahead.nextRollStartSeedIndex - 1;
            if (guaranteedSeedIndex < 0 || guaranteedSeedIndex >= seeds.length) return '---';

            const guaranteedSeed = seeds[guaranteedSeedIndex];
            const uberPool = gachaConfig.pool['uber'] || [];
            const totalUbers = uberPool.length;
            if (totalUbers === 0) return '---';

            const slotIndex = guaranteedSeed % totalUbers;

            return `(S${guaranteedSeedIndex + 1})${guaranteedSeed}<br>${totalUbers}<br>${slotIndex}`;
        }
        // --- End of helper functions ---



        function generateRollsTable() {
            try {
                if (Object.keys(gachaMasterData).length === 0) { return; }
                const initialSeed = parseInt(document.getElementById('seed').value, 10);
                const numRolls = currentRolls;
                if (isNaN(initialSeed) || isNaN(numRolls)) {
                    document.getElementById('rolls-table-container').innerHTML = '<p class="error">エラー: 有効な値を入力してください。</p>';
                    return;
                }
                
                const seeds = [];
                const rngForSeeds = new Xorshift32(initialSeed);
                for (let i = 0; i < numRolls * 15 + 20; i++) { seeds.push(rngForSeeds.next()); } // Increased seed generation

                const simConfigInput = document.getElementById('sim-config').value.trim();
                let simConfigs = [];
                
                if (simConfigInput) {
                    simConfigs = parseSimConfig(simConfigInput);
                    simConfigs.forEach(sim => {
                        if (gachaMasterData.gachas[sim.id]) {
                            sim.gachaConfig = gachaMasterData.gachas[sim.id];
                        }
                        const gachaIdInTable = sim.g ? `${sim.id}g` : sim.id;
                        const hasGuaranteed = tableGachaIds.includes(`${sim.id}g`);
                        if (!tableGachaIds.includes(gachaIdInTable)) {
                            if (sim.g) {
                                tableGachaIds.push(gachaIdInTable);
                            } else {
                                if (!hasGuaranteed) {
                                    tableGachaIds.push(gachaIdInTable);
                                }
                            }
                        }
                    });
                }
                
                const uniqueGachaIds = [...new Set(tableGachaIds.map(id => id.replace('g', '')))];
                const gachaConfigs = uniqueGachaIds.map(id => gachaMasterData.gachas[id]).filter(Boolean);

                const highlightMap = new Map();
                const simulationResults = [];
                
                let rngForText = new Xorshift32(initialSeed);
                let currentSeedIndex = 0;
                let lastDrawForHighlight = { rarity: null, charId: null };
                let pathDetails = [];
                let totalSimRolls = 0;

                if (simConfigs.length > 0) {
                    for (const sim of simConfigs) {
                        if (!sim.gachaConfig) continue; 
                        const isGuaranteedPath = sim.g && sim.rolls === 11;
                        
                        if (isGuaranteedPath) {
                            const startTrack = (currentSeedIndex % 2 === 0) ? 'A' : 'B'; 
                            const startRow = Math.floor(currentSeedIndex / 2);
                            for (let i = 0; i < 10; i++) {
                                const row = Math.floor(currentSeedIndex / 2);
                                const track = (currentSeedIndex % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;
                                highlightMap.set(`${row}-${track}`, sim.id);
                                const rollResult = rollWithSeedConsumptionFixed(currentSeedIndex, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;
                                pathDetails.push({ row, track, id: sim.id });
                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                currentSeedIndex += rollResult.seedsConsumed;
                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                simulationResults.push({ ...sim, result: rollResult, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                            }
                            if (startRow < numRolls) {
                                highlightMap.set(`${startRow}-${startTrack}G`, sim.id); 
                            }
                            if (currentSeedIndex >= seeds.length) continue;
                            const guaranteedResult = rollGuaranteedUber(currentSeedIndex, sim.gachaConfig, seeds);
                            currentSeedIndex += guaranteedResult.seedsConsumed;
                            for(let k = 0; k < guaranteedResult.seedsConsumed; k++) rngForText.next(); 
                            simulationResults.push({ ...sim, result: guaranteedResult, track: startTrack, isGuaranteed: true, rollNum: ++totalSimRolls });
                        } else {
                            for (let i = 0; i < sim.rolls; i++) {
                                const row = Math.floor(currentSeedIndex / 2);
                                const track = (currentSeedIndex % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;
                                highlightMap.set(`${row}-${track}`, sim.id);
                                const rollResult = rollWithSeedConsumptionFixed(currentSeedIndex, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;
                                pathDetails.push({ row, track, id: sim.id });
                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                currentSeedIndex += rollResult.seedsConsumed;
                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                simulationResults.push({ ...sim, result: rollResult, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                            }
                        }
                    }
                }
                finalSeedForUpdate = rngForText.seed;
                
                const tableData = Array(numRolls).fill(null).map(() => ({ A: [], B: [] }));
                
                gachaConfigs.forEach((config, gachaIndex) => {
                    if (!config) return;
                    let prevDrawA = { rarity: null, charId: null };
                    let prevDrawB = { rarity: null, charId: null };
                    for (let i = 0; i < numRolls; i++) {
                        const rollResultA = rollWithSeedConsumptionFixed(i * 2, config, seeds, prevDrawA);
                        tableData[i].A[gachaIndex] = { gachaId: config.id, roll: rollResultA };
                        prevDrawA = { rarity: rollResultA.rarity, charId: rollResultA.charId };
                        const rollResultB = rollWithSeedConsumptionFixed(i * 2 + 1, config, seeds, prevDrawB);
                        tableData[i].B[gachaIndex] = { gachaId: config.id, roll: rollResultB };
                        prevDrawB = { rarity: rollResultB.rarity, charId: rollResultB.charId };
                        if (i * 2 + 3 >= seeds.length) break; 
                    }
                });

                // --- Calculation Details Generation ---
                const firstGachaConfig = gachaConfigs[0];
                const details = {
                    A: { rarity: [], slot: [], reroll: [], guaranteed: [], dupeInfo: [] },
                    B: { rarity: [], slot: [], reroll: [], guaranteed: [], dupeInfo: [] }
                };

                if (showSeedColumns && firstGachaConfig) {
                    let lastDrawA = null;
                    let lastDrawB = null;
                    for (let i = 0; i < numRolls; i++) {
                        // Track A
                        const rollA = tableData[i].A[0].roll;
                        details.A.rarity.push(getRarityDetail('A', i, rollA, seeds));
                        details.A.slot.push(getSlotDetail('A', i, rollA, seeds));
                        details.A.reroll.push(getRerollDetail('A', i, rollA, firstGachaConfig, seeds));
                        details.A.guaranteed.push(getGuaranteedDetail('A', i, firstGachaConfig, seeds, lastDrawA));
                        const isDupeA = rollA.isRerolled;
                        const isForceableA = canBeForced('A', i, firstGachaConfig.id, tableData, gachaConfigs);
                        const isAvoidableA = canBeAvoided('A', i, firstGachaConfig.id, tableData, gachaConfigs);
                        details.A.dupeInfo.push({ isDupe: isDupeA, isForceable: isForceableA, isAvoidable: isAvoidableA });
                        lastDrawA = { rarity: rollA.rarity, charId: rollA.charId };

                        // Track B
                        const rollB = tableData[i].B[0].roll;
                        details.B.rarity.push(getRarityDetail('B', i, rollB, seeds));
                        details.B.slot.push(getSlotDetail('B', i, rollB, seeds));
                        details.B.reroll.push(getRerollDetail('B', i, rollB, firstGachaConfig, seeds));
                        details.B.guaranteed.push(getGuaranteedDetail('B', i, firstGachaConfig, seeds, lastDrawB));
                        const isDupeB = rollB.isRerolled;
                        const isForceableB = canBeForced('B', i, firstGachaConfig.id, tableData, gachaConfigs);
                        const isAvoidableB = canBeAvoided('B', i, firstGachaConfig.id, tableData, gachaConfigs);
                        details.B.dupeInfo.push({ isDupe: isDupeB, isForceable: isForceableB, isAvoidable: isAvoidableB });
                        lastDrawB = { rarity: rollB.rarity, charId: rollB.charId };
                    }
                }
                // --- End of Calculation Details ---

                const cellSimConfigs = new Map();
                const cellSimConfigs_Alt = new Map();
                const speciallyContinuedLinks = new Map();
                
                let startSeedIndex = currentSeedIndex;
                let startRow = Math.floor(startSeedIndex / 2);
                let startTrack = (startSeedIndex % 2 === 0) ? 'A' : 'B';
                let newRow1Index = startRow; 
                let baseConfig = simConfigInput;

                if (simConfigInput === '') {
                    newRow1Index = 0;
                    startTrack = 'A';
                }

                const getCellDataFull = (track, row, gachaId) => {
                    const key = `${track}-${row}-${gachaId}`;
                    const gachaIndex = gachaConfigs.findIndex(c => c.id === gachaId);
                    if (row < 0 || row >= numRolls || gachaIndex === -1 || !tableData[row] || !tableData[row][track][gachaIndex]) {
                        return { config: cellSimConfigs.get(key) || null, roll: null, seedsConsumed: 0 };
                    }
                    const roll = tableData[row][track][gachaIndex].roll;
                    return { config: cellSimConfigs.get(key) || null, roll: roll, seedsConsumed: roll.seedsConsumed };
                };
                
                const getPrevData = (track, i, gachaId) => getCellDataFull(track, i - 1, gachaId);
                const getPrevPrevCrossTrackData = (crossTrack, i, gachaId) => getCellDataFull(crossTrack, i - 2, gachaId);

                if (pathDetails.length > 0) {
                    const lastStep = pathDetails[pathDetails.length - 1];
                    let lastHighlightedConfig = simConfigInput;
                    if (simConfigInput.endsWith('g')) {
                        const parsed = parseSimConfig(simConfigInput);
                        const lastPart = parsed.pop();
                        if (lastPart && lastPart.g && lastPart.rolls === 11) {
                            lastPart.rolls = 10;
                            lastPart.g = false;
                            parsed.push(lastPart);
                            lastHighlightedConfig = stringifySimConfig(parsed);
                        }
                    }
                    cellSimConfigs.set(`${lastStep.track}-${lastStep.row}-${lastStep.id}`, lastHighlightedConfig);
                    
                    for (let i = pathDetails.length - 2; i >= 0; i--) {
                        const currentStep = pathDetails[i];
                        const nextStep = pathDetails[i + 1];
                        const nextConfigStr = cellSimConfigs.get(`${nextStep.track}-${nextStep.row}-${nextStep.id}`);
                        const currentConfigStr = decrementLastRollOrRemoveSegment(nextConfigStr);
                        cellSimConfigs.set(`${currentStep.track}-${currentStep.row}-${currentStep.id}`, currentConfigStr);
                    }
                    
                    gachaConfigs.forEach(config => {
                        pathDetails.forEach(step => {
                            if (config.id === step.id) return;
                            const i = step.row;
                            const cellKey = `${step.track}-${i}-${config.id}`;
                            const primaryCellKey = `${step.track}-${i}-${step.id}`;
                            const primaryConfigStr = cellSimConfigs.get(primaryCellKey);
                            if (primaryConfigStr === '' || primaryConfigStr === null || typeof primaryConfigStr === 'undefined') {
                                cellSimConfigs.set(cellKey, null);
                            } else {
                                let newConfig = parseSimConfig(primaryConfigStr);
                                if (newConfig.length > 0) {
                                    newConfig[newConfig.length - 1].id = config.id;
                                    cellSimConfigs.set(cellKey, stringifySimConfig(newConfig));
                                } else {
                                    cellSimConfigs.set(cellKey, null);
                                }
                            }
                        });
                    });
                    
                    const tracksInPath = [...new Set(pathDetails.map(step => step.track))];
                    if (tracksInPath.length === 1) {
                        const primaryTrack = tracksInPath[0];
                        const oppositeTrack = (primaryTrack === 'A') ? 'B' : 'A';
                        const highlightedRows = [...new Set(pathDetails.map(step => step.row))];
                        highlightedRows.forEach(row => {
                             gachaConfigs.forEach(config => {
                                 cellSimConfigs.set(`${oppositeTrack}-${row}-${config.id}`, null);
                             });
                        });
                    }
                }

                for (let i = newRow1Index; i < numRolls; i++) {
                    gachaConfigs.forEach(config => {
                        const id = config.id;
                        let configA = null;
                        let configB = null;
                        if (i === newRow1Index) {
                            if (startTrack === 'A') {
                                configA = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                            } else {
                                configB = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                            }
                        } else {
                            const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                            const prevA = getPrevData('A', i, id);
                            const isPrevASpecial = speciallyContinuedLinks.get(`A-${i - 1}-${id}`);
                            if (prevA.config && (prevA.seedsConsumed <= 2 || isPrevASpecial)) {
                                configA = incrementLastRoll(prevA.config);
                            }
                            const prevPrevB = getPrevPrevCrossTrackData('B', i, id);
                            let seedsConsumedForPrevPrevB = prevPrevB.seedsConsumed;
                            const lastPathDetail = pathDetails[pathDetails.length - 1];
                            if (lastPathDetail && lastPathDetail.row === i - 2 && lastPathDetail.track === 'B' && lastPathDetail.id === id) {
                                const lastSimStep = simulationResults[simulationResults.length - 1];
                                seedsConsumedForPrevPrevB = lastSimStep.result.seedsConsumed;
                            }
                            if (prevPrevB.config && seedsConsumedForPrevPrevB === 3) {
                                configA = incrementLastRoll(prevPrevB.config);
                            }
                            const triggerAltB = cellSimConfigs_Alt.get(`B-${i - 2}-${id}`);
                            if (prevPrevB.config && seedsConsumedForPrevPrevB === 2 && triggerAltB && triggerAltB.link) {
                                configA = incrementLastRoll(triggerAltB.link);
                            }
                            const prevB = getPrevData('B', i, id);
                            const isPrevBSpecial = speciallyContinuedLinks.get(`B-${i - 1}-${id}`);
                            if (prevB.config && (prevB.seedsConsumed <= 2 || isPrevBSpecial)) {
                                configB = incrementLastRoll(prevB.config);
                            }
                            const prevA_for_B = getPrevData('A', i, id);
                            let seedsConsumedForPrevA = prevA_for_B.seedsConsumed;
                            if (lastPathDetail && lastPathDetail.row === i - 1 && lastPathDetail.track === 'A' && lastPathDetail.id === id) {
                                 const lastSimStep = simulationResults[simulationResults.length - 1];
                                seedsConsumedForPrevA = lastSimStep.result.seedsConsumed;
                            }
                            if (prevA_for_B.config && seedsConsumedForPrevA === 3) {
                                configB = incrementLastRoll(prevA_for_B.config);
                            }
                            const triggerAltA = cellSimConfigs_Alt.get(`A-${i - 1}-${id}`);
                            if (prevA_for_B.config && seedsConsumedForPrevA === 2 && triggerAltA && triggerAltA.link) {
                                configB = incrementLastRoll(triggerAltA.link);
                            }
                            if (gachaIndex !== -1) {
                                const prevRollDataA = tableData[i - 1]?.A[gachaIndex];
                                if (prevRollDataA && prevRollDataA.roll.isRerolled) { 
                                    const prevAltDataA = cellSimConfigs_Alt.get(`A-${i - 1}-${id}`);
                                    const prevConfigStrA = cellSimConfigs.get(`A-${i - 1}-${id}`);
                                    if (prevAltDataA && prevAltDataA.link && prevConfigStrA) {
                                        configA = incrementLastRoll(prevAltDataA.link);
                                        speciallyContinuedLinks.set(`A-${i}-${id}`, true); 
                                    }
                                }
                                const prevRollDataB = tableData[i - 1]?.B[gachaIndex];
                                if (prevRollDataB && prevRollDataB.roll.isRerolled) {
                                    const prevAltDataB = cellSimConfigs_Alt.get(`B-${i - 1}-${id}`);
                                    const prevConfigStrB = cellSimConfigs.get(`B-${i - 1}-${id}`);
                                    if (prevAltDataB && prevAltDataB.link && prevConfigStrB) {
                                        configB = incrementLastRoll(prevAltDataB.link);
                                        speciallyContinuedLinks.set(`B-${i}-${id}`, true); 
                                    }
                                }
                            }
                        }
                        cellSimConfigs.set(`A-${i}-${id}`, configA);
                        cellSimConfigs.set(`B-${i}-${id}`, configB);
                        const altDataA = checkAvoidanceAndForcing('A', i, id, tableData, gachaConfigs, cellSimConfigs, newRow1Index);
                        const altDataB = checkAvoidanceAndForcing('B', i, id, tableData, gachaConfigs, cellSimConfigs, newRow1Index);
                        if (altDataA.link) { cellSimConfigs_Alt.set(`A-${i}-${id}`, altDataA); }
                        if (altDataB.link) { cellSimConfigs_Alt.set(`B-${i}-${id}`, altDataB); }
                    });
                }

                const buttonHtml = `<button class="add-gacha-btn" onclick="addGachaColumn()">＋列を追加</button>`;
                let totalGachaCols = 0;
                tableGachaIds.forEach(idWithG => {
                    const id = idWithG.replace('g', '');
                    if (gachaMasterData.gachas[id]) {
                        totalGachaCols += idWithG.endsWith('g') ? 2 : 1;
                    }
                });
                
                const calcColClass = `calc-column ${showSeedColumns ? '' : 'hidden'}`;
                const calcColSpan = showSeedColumns ? 5 : 0;
                const totalTrackSpan = calcColSpan + totalGachaCols;

                let tableHtml = `<table><thead>
                    <tr>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th colspan="${totalTrackSpan}">A ${buttonHtml}</th>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th colspan="${totalTrackSpan}">B</th>
                    </tr>
                    <tr>`;
                
                // A Track Headers
                tableHtml += `
                    <th class="${calcColClass}">S1<br>rarity</th>
                    <th class="${calcColClass}">S2<br>slot</th>
                    <th class="${calcColClass}">S3<br>ReRoll</th>
                    <th class="${calcColClass}">Guaranteed<br>slot</th>
                    <th class="${calcColClass}">被り有無<br>誘発/回避可否</th>
                `;
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;
                    const removeButtonHtml = `<button onclick="removeGachaColumn(${index})">x</button>`;
                    const gButtonHtml = `<button onclick="toggleGuaranteedColumn(${index})">G</button>`;
                    let selectorHtml = `<select onchange="updateGachaSelection(this, ${index})">`;
                    Object.values(gachaMasterData.gachas).filter(g => g.sort < 800).sort((a, b) => a.sort - b.sort).forEach(gacha => {
                        selectorHtml += `<option value="${gacha.id}" ${gacha.id === id ? 'selected' : ''}>${gacha.name}</option>`;
                    });
                    selectorHtml += '</select>';
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;
                    const headerClass = isGuaranteed ? '' : 'class="gacha-column"';
                    tableHtml += `<th ${headerClass} ${isGuaranteed ? ' colspan="2"' : ''}><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                });

                // B Track Headers
                tableHtml += `
                    <th class="${calcColClass}">S1<br>rarity</th>
                    <th class="${calcColClass}">S2<br>slot</th>
                    <th class="${calcColClass}">S3<br>ReRoll</th>
                    <th class="${calcColClass}">Guaranteed<br>slot</th>
                    <th class="${calcColClass}">被り有無<br>誘発/回避可否</th>
                `;
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;
                    const headerClass = isGuaranteed ? '' : 'class="gacha-column"';
                    tableHtml += `<th ${headerClass} ${isGuaranteed ? ' colspan="2"' : ''}>${headerName}</th>`;
                });

                tableHtml += `</tr></thead><tbody>`;

                function generateCellContent(track, i, id) {
                    const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                    if (gachaIndex === -1 || !tableData[i] || !tableData[i][track][gachaIndex] || !tableData[i][track][gachaIndex].roll) return '<td>N/A</td>';
                    const fullRoll = tableData[i][track][gachaIndex].roll;
                    const configStr = cellSimConfigs.get(`${track}-${i}-${id}`);
                    const altData = cellSimConfigs_Alt.get(`${track}-${i}-${id}`) || { link: null, rerollCharName: null };
                    const altConfigStr = altData.link;
                    let highlightClass = (highlightMap.get(`${i}-${track}`) === id) ? ' highlight' : '';
                    if (highlightClass && fullRoll.rarity === 'uber') { highlightClass = ' highlight-uber'; } 
                    let cellStyle = '';
                    if (!highlightClass) {
                        const seedVal = (track === 'A' ? seeds[i * 2] : seeds[i * 2 + 1]) % 10000;
                        if (seedVal >= 9970) { cellStyle = 'background-color: #DDA0DD;'; } 
                        else if (seedVal >= 9940) { cellStyle = 'background-color: #9370DB;'; } 
                        else if (seedVal >= 9470) { cellStyle = 'background-color: #FF4C4C;'; } 
                        else if (seedVal >= 9070) { cellStyle = 'background-color: #FFB6C1;'; } 
                        else if (seedVal >= 6970) { cellStyle = 'background-color: #FFDAB9;'; } 
                        else if (seedVal >= 6470) { cellStyle = 'background-color: #FFFFE0;'; } 
                    }
                    let cellContent = '';
                    let nextAddress = null;
                    if (fullRoll.seedsConsumed === 3) {
                        const destTrack = (track === 'A' ? 'B' : 'A');
                        const destRow = (track === 'A' ? i + 1 : i + 2);
                        if (destRow < numRolls) { nextAddress = `${destRow + 1}${destTrack}`; }
                    } 
                    let addressPrefix = nextAddress ? `${nextAddress}) ` : '';
                    if (fullRoll.isRerolled) {
                        const originalCharName = fullRoll.originalChar.name;
                        const rerollCharName = fullRoll.finalChar.name;
                        let originalDisplay = originalCharName;
                        let rerollDisplay = rerollCharName;
                        if (configStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${configStr}'; resetAndGenerateTable();`;
                            rerollDisplay = `<a href="${href}" onclick="${onclickAction}">${addressPrefix}${rerollCharName}</a>`;
                        } else {
                            rerollDisplay = `${addressPrefix}${rerollCharName}`;
                        }
                        if (altConfigStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(altConfigStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${altConfigStr}'; resetAndGenerateTable();`;
                            originalDisplay = `<a href="${href}" onclick="${onclickAction}">${originalCharName}</a>`;
                        }
                        cellContent = `${originalDisplay}<br>${rerollDisplay}`;
                    } else {
                        const originalCharName = fullRoll.finalChar.name;
                        let originalDisplay = originalCharName;
                        if (configStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${configStr}'; resetAndGenerateTable();`;
                            originalDisplay = `<a href="${href}" onclick="${onclickAction}">${addressPrefix}${originalCharName}</a>`;
                        } else {
                            originalDisplay = `${addressPrefix}${originalCharName}`;
                        }
                        cellContent = originalDisplay;
                        if (altConfigStr) {
                            const rerollCharName = altData.rerollCharName || "??";
                            let inducedAddress = null;
                            const destTrack = (track === 'A' ? 'B' : 'A');
                            const destRow = (track === 'A' ? i + 1 : i + 2);
                            if (destRow < numRolls) { inducedAddress = `${destRow + 1}${destTrack}`; }
                            const inducedAddressPrefix = inducedAddress ? `${inducedAddress}) ` : '';
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(altConfigStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${altConfigStr}'; resetAndGenerateTable();`;
                            const rerollDisplay = `<a href="${href}" onclick="${onclickAction}">${inducedAddressPrefix}${rerollCharName}</a>`;
                            cellContent = `${originalDisplay}<br>${rerollDisplay}`;
                        }
                    }
                    return `<td class="gacha-cell gacha-column${highlightClass}" style="${cellStyle}">${cellContent}</td>`;
                }

                for (let i = 0; i < numRolls; i++) {
                    let rowHtml = `<tr><td class="col-no">${i + 1}</td>`;
                    
                    // --- Track A Columns ---
                    if (showSeedColumns) {
                        rowHtml += `<td class="${calcColClass}">${details.A.rarity[i] || ''}</td>`;
                        rowHtml += `<td class="${calcColClass}">${details.A.slot[i] || ''}</td>`;
                        rowHtml += `<td class="${calcColClass}">${details.A.reroll[i] || ''}</td>`;
                        rowHtml += `<td class="${calcColClass}">${details.A.guaranteed[i] || ''}</td>`;
                        const dupeInfoA = details.A.dupeInfo[i];
                        if (dupeInfoA) {
                            const dupeText = dupeInfoA.isDupe ? 'True' : 'False';
                            const forceText = dupeInfoA.isDupe ? '---' : (dupeInfoA.isForceable ? 'True' : 'False');
                            const avoidText = !dupeInfoA.isDupe ? '---' : (dupeInfoA.isAvoidable ? 'True' : 'False');
                            rowHtml += `<td class="${calcColClass}">${dupeText}<br>${forceText}<br>${avoidText}</td>`;
                        } else {
                            rowHtml += `<td class="${calcColClass}">---</td>`;
                        }
                    }
                    
                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteedColumn = idWithG.endsWith('g');
                        const id = isGuaranteedColumn ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return; 
                        rowHtml += generateCellContent('A', i, id);
                        if (isGuaranteedColumn) {
                            let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)] && tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll) ? { rarity: tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll.charId } : null;
                            const { name: guaranteedChar, nextRollStartSeedIndex } = calculateGuaranteedLookahead(i * 2, gachaConfig, seeds, lastDraw);
                            let guaranteedHighlight = '';
                            let content = guaranteedChar;
                            let nextAddressG = null;
                            if (nextRollStartSeedIndex !== null && nextRollStartSeedIndex < seeds.length) {
                                const nextRow = Math.floor(nextRollStartSeedIndex / 2);
                                const nextTrack = (nextRollStartSeedIndex % 2 === 0) ? 'A' : 'B';
                                nextAddressG = `${nextRow + 1}${nextTrack}`;
                            }
                            if (highlightMap.get(`${i}-AG`) === id) { guaranteedHighlight = ' class="highlight-uber"'; }
                            const configStrA = cellSimConfigs.get(`A-${i}-${id}`);
                            const configG_A = generateGuaranteedConfig(configStrA, id); 
                            let addressPrefixG = nextAddressG ? `${nextAddressG}) ` : '';
                            if (configG_A) {
                                const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_A)}&gachas=${tableGachaIds.join('-')}`;
                                const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_A}'; resetAndGenerateTable();`;
                                content = `<a href="${hrefG}" onclick="${onclickActionG}">${addressPrefixG}${guaranteedChar}</a>`;
                            } 
                            if (!content.includes('<a')) { content = `${addressPrefixG}${guaranteedChar}`}
                            rowHtml += `<td class="gacha-column"${guaranteedHighlight}>${content}</td>`;
                        }
                    });

                    rowHtml += `<td class="col-no">${i + 1}</td>`;

                    // --- Track B Columns ---
                     if (showSeedColumns) {
                        rowHtml += `<td class="${calcColClass}">${details.B.rarity[i] || ''}</td>`;
                        rowHtml += `<td class="${calcColClass}">${details.B.slot[i] || ''}</td>`;
                        rowHtml += `<td class="${calcColClass}">${details.B.reroll[i] || ''}</td>`;
                        rowHtml += `<td class="${calcColClass}">${details.B.guaranteed[i] || ''}</td>`;
                        const dupeInfoB = details.B.dupeInfo[i];
                        if (dupeInfoB) {
                            const dupeText = dupeInfoB.isDupe ? 'True' : 'False';
                            const forceText = dupeInfoB.isDupe ? '---' : (dupeInfoB.isForceable ? 'True' : 'False');
                            const avoidText = !dupeInfoB.isDupe ? '---' : (dupeInfoB.isAvoidable ? 'True' : 'False');
                            rowHtml += `<td class="${calcColClass}">${dupeText}<br>${forceText}<br>${avoidText}</td>`;
                        } else {
                            rowHtml += `<td class="${calcColClass}">---</td>`;
                        }
                    }

                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteedColumn = idWithG.endsWith('g');
                        const id = isGuaranteedColumn ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return;
                        rowHtml += generateCellContent('B', i, id);
                        if (isGuaranteedColumn) {
                             let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)] && tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll) ? { rarity: tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll.charId } : null;
                             const { name: guaranteedChar, nextRollStartSeedIndex } = calculateGuaranteedLookahead(i * 2 + 1, gachaConfig, seeds, lastDraw);
                             let guaranteedHighlight = '';
                             let content = guaranteedChar;
                             let nextAddressG = null;
                             if (nextRollStartSeedIndex !== null && nextRollStartSeedIndex < seeds.length) {
                                const nextRow = Math.floor(nextRollStartSeedIndex / 2);
                                const nextTrack = (nextRollStartSeedIndex % 2 === 0) ? 'A' : 'B';
                                nextAddressG = `${nextRow + 1}${nextTrack}`;
                             }
                             if (highlightMap.get(`${i}-BG`) === id) { guaranteedHighlight = ' class="highlight-uber"'; }
                             const configStrB = cellSimConfigs.get(`B-${i}-${id}`);
                             const configG_B = generateGuaranteedConfig(configStrB, id); 
                             let addressPrefixG = nextAddressG ? `${nextAddressG}) ` : '';
                             if (configG_B) {
                                const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_B)}&gachas=${tableGachaIds.join('-')}`;
                                const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_B}'; resetAndGenerateTable();`;
                                content = `<a href="${hrefG}" onclick="${onclickActionG}">${addressPrefixG}${guaranteedChar}</a>`;
                             }
                             if (!content.includes('<a')) { content = `${addressPrefixG}${guaranteedChar}`}
                             rowHtml += `<td class="gacha-column"${guaranteedHighlight}>${content}</td>`;
                        }
                    });
                    
                    rowHtml += `</tr>`;
                    tableHtml += rowHtml;
                }

                tableHtml += '</tbody></table>';
                document.getElementById('rolls-table-container').innerHTML = tableHtml;

                let simulationOutputString = '--- シミュレーション詳細 ---\n';
                if (simulationResults.length > 0) {
                    simulationResults.forEach((sim, index) => {
                        if (!sim || !sim.result) return;
                        const result = sim.result;
                        let line;
                        if (sim.isGuaranteed) {
                             line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | uber guaranteed ${result.s0} ${result.finalChar.name} (確定枠のシード)`;
                        } else {
                            line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | ${result.s0}(${result.rarity})${result.rarity}`;
                            if (result.isRerolled) {
                                line += ` ${result.originalChar.name} -> ${result.s2} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            } else {
                                line += `／${result.s1} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            }
                        }
                        simulationOutputString += line + '\n';
                    });
                }
                document.getElementById('result').textContent = simulationOutputString;

                updateUrlParams();
            } catch (e) {
                document.getElementById('rolls-table-container').innerHTML = `<p class="error">テーブルの生成中にエラーが発生しました: ${e.message}</p>`;
                document.getElementById('result').textContent = `エラー: ${e.stack}`; // エラー詳細を表示
                console.error(e);
            }
        }

        window.onload = loadAndProcessData;
    </script>
</body>
</html>
