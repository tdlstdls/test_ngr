<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NanchtteGachaRollSimulator</title>
    <link rel="icon" href="data:,">
    <style>
        body { font-family: Arial, sans-serif; padding: 10px; font-size: 12px; }
        h1 { font-size: 1em; font-weight: bold; text-align: center; margin-bottom: 10px;}
        #controls label, #controls input, #controls button, #controls span { margin-right: 10px; margin-bottom: 10px; display: inline-block; }
        .error { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 4px; text-align: left; }
        th { background-color: #f2f2f2; text-align: center; vertical-align: middle; position: relative; }
        .highlight { background-color: #CCFFCE; } /* Light Green */
        .highlight-uber { background-color: #6EFF72; color: black; } /* Brighter Green */
        .gacha-select-header { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; }
        .gacha-select-header span { margin-left: 5px; font-size: 10px; }
        .gacha-select-header select {
            width: 20px;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") no-repeat right / .8em;
            padding-right: 1em;
        }
        .gacha-select-header button { font-size: 10px; padding: 2px 4px; margin-left: 4px; }
        .add-gacha-btn { font-size: 12px; font-weight: normal; padding: 2px 6px; margin-left: 15px; }
        #result { margin-top: 20px; border: 1px solid #ccc; padding: 10px; white-space: pre-wrap; font-family: monospace; background-color: #f9f9f9; max-height: 300px; overflow-y: auto; }
        #table-actions { text-align: center; margin-top: 10px; }
        #table-actions button { margin: 0 5px; }

        /* Toggle visibility classes */
        .hidden { display: none; }
        .seed-column { width: 75px; text-align: center; font-size: 10px; color: #555; }
        .calc-column { width: 80px; text-align: left; font-size: 10px; color: #555; white-space: pre-wrap; word-break: break-all; }
        .gacha-column { width: 160px; }
        .col-no { width: 35px; text-align: center; white-space: nowrap; }
        #toggle-description, #toggle-sim-input, #toggle-seed-input { cursor: pointer; color: blue; text-decoration: underline; margin-bottom: 10px; display: block; text-align: center; }
        #description-content { border: 1px solid #ccc; padding: 10px; margin-top: 10px; margin-bottom: 10px; white-space: pre-wrap; font-size: 11px; }


        @media screen and (max-width: 768px) {
            body {
                padding: 5px;
                -webkit-text-size-adjust: 100%;
            }
            #controls {
                padding: 10px;
            }
            #controls label,
            #controls input,
            #controls button, 
            #controls span {
                display: block;
                width: 95%;
                margin: 0 auto 10px auto;
                box-sizing: border-box;
            }
            /* ★ 修正: 両方のテーブルコンテナに適用 */
            #rolls-table-container,
            #serial-table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            table {
                width: auto;
                min-width: 800px;
            }
            th, td {
                padding: 4px;
                font-size: 11px;
                line-height: 1.3;
            }
            td.gacha-cell {
                word-break: break-word;
            }
            .gacha-select-header span {
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <h1>NanchtteGachaRollSimulator</h1>

    <div id="toggle-description" onclick="toggleDescription()">概要を非表示</div>
    <div id="description-content">概要
このシミュレーターはロールズのルート取り専用に作成したものです。本家のロールズと違い、操作が非常に分かりにくいので、操作方法を簡単に説明します。
（作成者の想定した使い方）
１，SEED欄にシーカー等で調べた開始前SEEDを入力（例）12345
２．表のA列タイトルのガチャ名の左にあるフィルダウンリストから引きたいガチャを選択（例）ウルトラソウルズ、波動バスターズ
なお、他のガチャも引きたい場合は「A」の横の「+列を追加」で追加
３．引きたい順に表の上の方からキャラをタップしていく（例）、11A左：うらしまタロウ、12A右：前田慶次、19A左：きんたろう、（ウルトラソウルズの右の「G」をタップして表示して）25AG左：ももたろう、37B左：花咲かじいさん、・・・
なお、キャラをタップするとそのマスから11連確定等を使わないと到達できないマスはキャラ名をタップしても反応しなくなります
SEED更新ボタンを押すとシミュレーションにより薄緑色等でハイライトされた最後のマスの最終SEEDが反映され、表が更新されます
※機能が少なく、エラーも多いので、少しずつ対応していくつもりです</div>

    <div id="controls">
        <button onclick="updateSeedFromSim()">SEED更新</button>
        <span id="toggle-seed-input" onclick="showSeedInput()">SEED入力</span>
        <div id="seed-controls" class="hidden">
            <label for="seed">SEED:</label>
            <input type="number" id="seed" value="12345" min="1" max="4294967295" onchange="resetAndGenerateTable()">
        </div>
        <span id="toggle-sim-input" onclick="showSimInput()">シミュレーションテキスト入力欄表示</span>
        <div id="simulation-controls" class="hidden">
            <label for="sim-config">シミュレーション:</label>
            <input type="text" id="sim-config" placeholder="ガチャID-ロール数" onchange="resetAndGenerateTable()">
            <button onclick="clearSimConfig()">クリア</button>
        </div>
    </div>

    <div id="rolls-table-container"></div>
    <div id="serial-table-container"></div>
    
    <div id="table-actions">
        <button onclick="addMoreRows(100)">100行追加する</button>
        <button id="toggle-seed-btn" onclick="toggleSeedColumns()">SEEDを表示</button>
        <button id="toggle-result-btn" onclick="toggleResultDisplay()">計算過程を表示</button>
    </div>
    <div id="result"></div>

    <script>
        let gachaMasterData = {};
        const dataFiles = ['data/cats.js', 'data/gacha.js'];
        let tableGachaIds = [];
        let currentRolls = 100;
        let showSeedColumns = false;
        let showResultDisplay = false;
        let finalSeedForUpdate = null; // SEED更新ボタン用

        // ★ 動的表示用のグローバル変数
        let gachaDetailsForAllGachas = {};
        let gachaConfigsForRevert = [];

        function toggleDescription() {
            const content = document.getElementById('description-content');
            const toggle = document.getElementById('toggle-description');
            const isHidden = content.classList.toggle('hidden');
            toggle.textContent = isHidden ? '概要を表示' : '概要を非表示';
        }

        function showSimInput() {
            // 'simulation-controls' というIDを持つ要素を取得
            var simControls = document.getElementById('simulation-controls');
            // 'hidden' クラスをトグルする
            simControls.classList.toggle('hidden');
        }

        function showSeedInput() {
            // 'seed-controls' というIDを持つ要素を取得
            var seedControls = document.getElementById('seed-controls');
            // 'hidden' クラスが付いていれば外し、付いていなければ付ける
            seedControls.classList.toggle('hidden');
        }

        function clearSimConfig() {
            document.getElementById('sim-config').value = '';
            resetAndGenerateTable();
        }

        const fallbackCats = [
            {id:31,name:"ネコぼさつ",rarity:3},{id:32,name:"ネコ番長",rarity:3},{id:33,name:"ネコザイル",rarity:3},{id:34,name:"ねこタツ",rarity:3},{id:35,name:"ネコルガ",rarity:4},{id:36,name:"オタネコ",rarity:3},{id:37,name:"ネコスイマー",rarity:3},{id:38,name:"ネコホッピング",rarity:2},{id:39,name:"ネコ車輪",rarity:2},{id:40,name:"ネコリンゴ",rarity:3},{id:41,name:"ネコバスたぶ",rarity:3},{id:42,name:"ネコエステ",rarity:2},{id:43,name:"ネコアイス",rarity:4},{id:44,name:"ネコマシン",rarity:4},{id:45,name:"鬼にゃんま",rarity:4},{id:47,name:"ねこジュラ",rarity:2},{id:48,name:"ねこファイター",rarity:2},{id:49,name:"ねこ海賊",rarity:2},{id:50,name:"ねこ泥棒",rarity:2},{id:51,name:"ねこ僧侶",rarity:2},{id:52,name:"ねこ占い師",rarity:2},{id:53,name:"ネコシャーマン",rarity:2},{id:56,name:"ネコ魔女",rarity:2},{id:57,name:"ネコアーチャー",rarity:2},{id:58,name:"ネコシュバリエ",rarity:4},{id:59,name:"ネコ魔剣士",rarity:2},{id:60,name:"ねこベビー",rarity:4},{id:62,name:"ねこ寿司",rarity:3},{id:76,name:"風神のウィンディ",rarity:4},{id:84,name:"地龍ソドム",rarity:4},{id:85,name:"聖龍メギドラ",rarity:4},{id:107,name:"召し豚のカイ",rarity:4},{id:108,name:"宝杖のカッパーマイン",rarity:4},{id:130,name:"金ネコ",rarity:3},{id:132,name:"ねねこ",rarity:3},{id:136,name:"ツルの恩返し",rarity:4},{id:144,name:"ねこナース",rarity:4},{id:145,name:"にゃんこ城Mini",rarity:3},{id:146,name:"ねこガンマン",rarity:2},{id:147,name:"たけうまねこ",rarity:2},{id:148,name:"ブリキネコ",rarity:2},{id:149,name:"ねこロッカー",rarity:2},{id:150,name:"ねこ人魚",rarity:2},{id:151,name:"窓辺の乙女ネコ",rarity:3},{id:152,name:"ネコバーベル",rarity:3},{id:153,name:"ネコスケート",rarity:3},{id:154,name:"ネコトースター",rarity:3},{id:169,name:"アシルガ",rarity:4},{id:170,name:"クビルガ",rarity:4},{id:171,name:"テコルガ",rarity:4},{id:172,name:"バララガ",rarity:4},{id:197,name:"キャットマンダディ",rarity:4},{id:198,name:"サイキックネコ",rarity:2},{id:199,name:"ねこ陰陽師",rarity:2},{id:200,name:"ネコサーファー",rarity:3},{id:201,name:"メタルネコ",rarity:3},{id:238,name:"おかめはちもくネコ",rarity:3},{id:239,name:"ボンボンネコ",rarity:3},{id:240,name:"見習いスニャイパー",rarity:3},{id:241,name:"トゲルガ",rarity:4},{id:258,name:"天空神ゼウス",rarity:4},{id:259,name:"守護神アヌビス",rarity:4},{id:260,name:"美女神アフロディーテ",rarity:4},{id:272,name:"太陽神アマテラス",rarity:4},{id:273,name:"繁栄神ガネーシャ",rarity:4},{id:287,name:"ももたろう",rarity:4},{id:308,name:"かさじぞう",rarity:4},{id:309,name:"うらしまタロウ",rarity:4},{id:317,name:"きんたろう",rarity:4},{id:326,name:"かぐやひめ",rarity:4},{id:377,name:"花咲かじいさん",rarity:4},{id:378,name:"鶴の恩返し",rarity:4},{id:440,name:"前田慶次",rarity:4},{id:444,name:"織田信長",rarity:4},{id:445,name:"伊達政宗",rarity:4},{id:446,name:"武田信玄",rarity:4},{id:447,name:"上杉謙信",rarity:4},{id:448,name:"真田幸村",rarity:4},{id:494,name:"成田甲斐",rarity:4},{id:496,name:"今川義元",rarity:4},{id:535,name:"猿かに合戦",rarity:4},{id:643,name:"舌切り雀",rarity:4},{id:724,name:"さるかに合戦",rarity:4},{id:812,name:"ちびネコヴァルキリー",rarity:4}
        ];
        const fallbackGacha = [
            {id:992, name:"波動バスターズ", rare:7000, supa:2500, uber:500, sort:1, cats:[812,724,643,535,494,440,317,273,272,260,259,258,448,447,446,445,444,201,145,132,130,238,239,240,524,523,496,378,377,326,308,309,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:452, name:"エアバスターズ", rare:7000, supa:2500, uber:500, sort:2, cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:523, name:"ギガントゼウス", rare:7000, supa:2500, uber:500, sort:3, cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]}
        ];

        async function loadAndProcessData() {
            const loadedData = {};
            try {
                for (const file of dataFiles) {
                    const response = await fetch(file);
                    if (!response.ok) throw new Error('Network response was not ok.');
                    const text = await response.text();
                    const jsonStr = text.substring(text.indexOf('['), text.lastIndexOf(']') + 1);
                    loadedData[file.split('/')[1].split('.')[0]] = JSON.parse(jsonStr);
                }
            } catch (e) {
                console.warn("Failed to load external data, using fallback data.", e);
                loadedData.cats = fallbackCats;
                loadedData.gacha = fallbackGacha;
            }

            const rarityMap = { 0: "nomal", 1: "ex", 2: "rare", 3: "super", 4: "uber", 5: "legend" };
            const catsMaster = {};
            for (const cat of loadedData.cats) { catsMaster[cat.id] = { ...cat, rarity: rarityMap[cat.rarity] || "rare" }; }
            const gachasMaster = {};
            for (const gacha of loadedData.gacha) {
                const pool = { rare: [], super: [], uber: [], legend: [], nomal: [], ex: [] };
                if (gacha.cats) {
                    for (const catId of gacha.cats) {
                        const catInfo = catsMaster[catId];
                        if (catInfo && pool[catInfo.rarity] !== undefined) pool[catInfo.rarity].push({ id: catInfo.id, name: catInfo.name });
                    }
                }
                gachasMaster[gacha.id] = {
                    id: gacha.id.toString(),
                    name: gacha.name || `ガチャID: ${gacha.id}`,
                    rarity_rates: { rare: gacha.rare || 0, super: gacha.supa || 0, uber: gacha.uber || 0, legend: gacha.legend || 0 },
                    pool: pool,
                    sort: gacha.sort
                };
            }
            gachaMasterData = { cats: catsMaster, gachas: gachasMaster };

            const urlParams = new URLSearchParams(window.location.search);
            const seedParam = urlParams.get('seed');
            const simConfigParam = urlParams.get('sim_config');
            const gachasParam = urlParams.get('gachas');

            if (gachasParam) {
                tableGachaIds = gachasParam.split('-');
            } else if (simConfigParam) {
                tableGachaIds = [];
            } else {
                const sortedGachas = Object.values(gachaMasterData.gachas)
                    .filter(gacha => gacha.sort < 800)
                    .sort((a, b) => a.sort - b.sort);
                if (sortedGachas.length > 0) {
                    tableGachaIds.push(sortedGachas[0].id);
                    if (sortedGachas.length > 1) {
                        tableGachaIds.push(sortedGachas[1].id);
                    }
                }
            }

            if (seedParam) {
                document.getElementById('seed').value = seedParam;
                showSeedInput(); // if seed is in URL, show the input
            }
            if (simConfigParam) {
                document.getElementById('sim-config').value = simConfigParam;
                showSimInput(); // if sim_config is in URL, show the input
            }

            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();

            resetAndGenerateTable();
        }
        
        function updateSeedFromSim() {
            if (finalSeedForUpdate) {
                document.getElementById('seed').value = finalSeedForUpdate;
                document.getElementById('sim-config').value = ''; // sim-config をブランクにする
                resetAndGenerateTable(); 
            }
        }

        function addMoreRows(count) {
            currentRolls += count;
            generateRollsTable();
        }

        function resetAndGenerateTable() {
            finalSeedForUpdate = null;
            // sim-config がブランクの場合のみ currentRolls をリセット
            if (document.getElementById('sim-config').value.trim() === '') {
                 currentRolls = 100;
            }
            generateRollsTable();
        }

        function updateGachaSelection(selectElement, index) {
            const originalIdWithG = tableGachaIds[index];
            const isGuaranteed = originalIdWithG.endsWith('g');
            let newId = selectElement.value;
            if (isGuaranteed) {
                newId += 'g';
            }
            tableGachaIds[index] = newId;
            generateRollsTable();
        }

        function addGachaColumn() {
            const sortedGachas = Object.values(gachaMasterData.gachas)
                .filter(gacha => gacha.sort < 800)
                .sort((a, b) => a.sort - b.sort);

            if (sortedGachas.length > 0) {
                tableGachaIds.push(sortedGachas[0].id);
                generateRollsTable();
            }
        }

        function removeGachaColumn(index) {
            tableGachaIds.splice(index, 1);
            generateRollsTable();
        }

        function toggleSeedColumns() {
            showSeedColumns = !showSeedColumns;
            generateRollsTable(); 
            updateToggleButtons();
        }

        function toggleResultDisplay() {
            showResultDisplay = !showResultDisplay;
            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();
        }
        function updateToggleButtons() {
            document.getElementById('toggle-seed-btn').textContent = showSeedColumns ? 'SEEDを非表示' : 'SEEDを表示';
            document.getElementById('toggle-result-btn').textContent = showResultDisplay ? '計算過程を非表示' : '計算過程を表示';
        }

        function updateUrlParams() {
            const seed = document.getElementById('seed').value;
            const simConfig = document.getElementById('sim-config').value;
            const urlParams = new URLSearchParams(window.location.search);

            if (seed) {
                urlParams.set('seed', seed);
            } else {
                urlParams.delete('seed');
            }
            if (simConfig) {
                urlParams.set('sim_config', simConfig);
            } else {
                urlParams.delete('sim_config');
            }
            if (tableGachaIds.length > 0) {
                urlParams.set('gachas', tableGachaIds.join('-'));
            } else {
                urlParams.delete('gachas');
            }

            const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
            // ★ 修正: history.pushState を try...catch で囲む
            try {
                window.history.pushState({path: newUrl}, '', newUrl);
            } catch (e) {
                console.warn("Could not update URL parameters:", e.message);
                // サンドボックス環境 (blob: や iframe) では pushState が失敗することがある
                // アプリの実行を継続するためにエラーを無視する
            }
        }

        class Xorshift32 { constructor(seed) { this.seed = (seed >>> 0) || 1; } next() { let x = this.seed; x ^= (x << 13); x ^= (x >>> 17); x ^= (x << 15); this.seed = x >>> 0; return this.seed; } }

        
        /**
         * 固定シード配列と開始インデックスを用いてガチャを一回実行し、シード消費を含む詳細を返す
         * @param {number} startIndex - seeds配列の開始インデックス
         * @param {object} gachaConfig - ガチャ設定
         * @param {number[]} seeds - 全シード値の配列
         * @param {object} lastDrawInfo - 直前のドロー情報 ({rarity, charId})
         * @returns {object} - ロール結果の詳細
         */
        function rollWithSeedConsumptionFixed(startIndex, gachaConfig, seeds, lastDrawInfo) {
            if (startIndex + 1 >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: null, s1: null, s2: null };
            
            // S0, S1, S2 are seeds[startIndex], seeds[startIndex+1], seeds[startIndex+2]
            const s0_seed = seeds[startIndex];
            const s1_seed = seeds[startIndex + 1];

            // Rarity Roll (based on S0)
            const rarityRoll = s0_seed % 10000;
            const rates = gachaConfig.rarity_rates || {};
            const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
            let currentRarity;
            if (rarityRoll < rareRate) { currentRarity = 'rare'; } else if (rarityRoll < rareRate + superRate) { currentRarity = 'super'; } else if (rarityRoll < rareRate + superRate + uberRate) { currentRarity = 'uber'; } else if (rarityRoll < rareRate + superRate + uberRate + legendRate) { currentRarity = 'legend'; } else { currentRarity = 'rare'; }
            
            const characterPool = gachaConfig.pool[currentRarity] || [];
            if (characterPool.length === 0) {
                // s2_seedも返すように修正 (誘発ロジックが参照するため)
                const s2_seed = (startIndex + 2 < seeds.length) ? seeds[startIndex + 2] : null;
                return { seedsConsumed: 2, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed, s1: s1_seed, s2: s2_seed };
            }
            
            // Character Roll (based on S1)
            const totalChars = characterPool.length;
            const charIndex = s1_seed % totalChars;
            let character = characterPool[charIndex];
            const originalChar = character;
            let seedsConsumed = 2;
            let isRerolled = false;
            let s2_seed = (startIndex + 2 < seeds.length) ? seeds[startIndex + 2] : null; // s2は常に読み込む
            let reRollIndex = null;
            let uniqueTotal = null;

            if (currentRarity === 'rare' && lastDrawInfo && lastDrawInfo.rarity === 'rare' && lastDrawInfo.charId === character.id) {
                // Rare Dupe Check
                const uniqueRareChars = characterPool.filter(c => c.id !== lastDrawInfo.charId);
                uniqueTotal = uniqueRareChars.length;
                
                if (uniqueTotal > 0) {
                    // Reroll is possible (3 seeds consumed)
                    if (s2_seed === null) { // s2 がない場合はデータ不足
                         return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: s0_seed, s1: s1_seed, s2: null };
                    }
                    
                    reRollIndex = s2_seed % uniqueTotal;
                    character = uniqueRareChars[reRollIndex];
                    isRerolled = true;
                    seedsConsumed = 3;
                } 
                // If uniqueTotal == 0, seedsConsumed remains 2, isRerolled remains false (unavoidable dupe).
            }
            
            return { 
                s0: s0_seed, s1: s1_seed, s2: s2_seed, 
                originalChar: originalChar, 
                finalChar: character, 
                isRerolled: isRerolled, 
                rarity: currentRarity, 
                charId: character.id, 
                charIndex: charIndex, 
                totalChars: totalChars, 
                uniqueTotal: uniqueTotal,
                reRollIndex: reRollIndex,
                seedsConsumed: seedsConsumed 
            };
        }

        function rollGuaranteedUber(startIndex, gachaConfig, seeds) {
            if (startIndex >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: 'uber', charId: null, s0: null };

            const s0_seed = seeds[startIndex];
            const currentRarity = 'uber';
            const characterPool = gachaConfig.pool[currentRarity] || [];
            const totalChars = characterPool.length;
            if (totalChars === 0) {
                return { seedsConsumed: 1, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed };
            }
            const charIndex = s0_seed % totalChars;
            const character = characterPool[charIndex];
            return { seedsConsumed: 1, finalChar: character, originalChar: character, isRerolled: false, rarity: currentRarity, charId: character.id, charIndex: charIndex, totalChars: totalChars, s0: s0_seed };
        }


        function calculateGuaranteedLookahead(startSeedIndex, gachaConfig, allSeeds, initialLastDraw) {
            if (!gachaConfig || !gachaConfig.pool['uber']) return { name: "N/A", nextSeed: null, nextRollStartSeedIndex: null };

            let seedCursor = startSeedIndex;
            let lastDraw = initialLastDraw;
            let nextSimSeedValue = null;

            for (let i = 0; i < 10; i++) {
                if (seedCursor + 1 >= allSeeds.length) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };

                const rollResult = rollWithSeedConsumptionFixed(seedCursor, gachaConfig, allSeeds, lastDraw);
                if (rollResult.seedsConsumed === 0) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
                
                seedCursor += rollResult.seedsConsumed;
                lastDraw = { rarity: rollResult.rarity, charId: rollResult.charId };
            }

            if (seedCursor >= allSeeds.length) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
            
            // Guaranteed roll (11th roll is 1-seed roll)
            const guaranteedRollResult = rollGuaranteedUber(seedCursor, gachaConfig, allSeeds);
            if (guaranteedRollResult.seedsConsumed === 0) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
            
            seedCursor += guaranteedRollResult.seedsConsumed;
            
            nextSimSeedValue = (seedCursor < allSeeds.length) ? allSeeds[seedCursor] : null;

            return { name: guaranteedRollResult.finalChar.name, nextSeed: nextSimSeedValue, nextRollStartSeedIndex: seedCursor };
        }

        function toggleGuaranteedColumn(index) {
            const idWithG = tableGachaIds[index];
            if (idWithG.endsWith('g')) {
                tableGachaIds[index] = idWithG.slice(0, -1);
            } else {
                tableGachaIds[index] = idWithG + 'g';
            }
            generateRollsTable();
        }

        // --- sim-config ヘルパー関数 ---
        function parseSimConfig(configStr) {
            if (!configStr) return []; // ★ null や '' の場合、空配列を返す
            const configs = [];
            const parts = configStr.split('-');
            for (let i = 0; i < parts.length; i += 2) {
                const id = parts[i];
                const rollStr = parts[i+1];
                if (id && rollStr) {
                    const isGuaranteed = rollStr.endsWith('g');
                    const rolls = parseInt(rollStr.replace('g', ''), 10);
                    configs.push({ id, rolls, g: isGuaranteed });
                }
            }
            return configs;
        }

        function stringifySimConfig(configArr) {
            return configArr.map(c => `${c.id}-${c.rolls}${c.g ? 'g' : ''}`).join('-');
        }
        
        /**
         * 最後のロール数を+1するか、11gの場合は次のセグメントを追加する (継続リンク用)
         * @param {string} configStr - sim-config文字列
         * @returns {string|null} - 更新されたsim-config文字列
         */
        function incrementLastRoll(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length > 0) {
                const last = configs[configs.length - 1];
                if (!last.g) { 
                    last.rolls += 1;
                } else {
                    // 11gの次は1
                    configs.push({ id: last.id, rolls: 1, g: false });
                }
            }
            return stringifySimConfig(configs);
        }

        /**
         * 最後のロール数を-1するか、ロール数が1の場合は最後のセグメントを削除する (Rule B: 逆算用)
         * @param {string} configStr - sim-config文字列
         * @returns {string|null} - 更新されたsim-config文字列
         */
        function decrementLastRollOrRemoveSegment(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length === 0) return null;

            const last = configs.pop();

            if (last.g) {
                // 確定枠からの逆算の場合 (Rule Aの逆算時)
                if (last.rolls === 11) {
                    last.rolls = 10;
                    last.g = false;
                    configs.push(last);
                }
            } else {
                // 通常抽選からの逆算の場合
                if (last.rolls > 1) {
                    last.rolls -= 1;
                    configs.push(last);
                }
                // last.rolls === 1 の場合、セグメントは削除
            }

            return configs.length > 0 ? stringifySimConfig(configs) : '';
        }

        /**
         * 確定枠のリンクを生成するロジック（隣接セルからの生成） (Rule E/確定枠のリンク設定)
         * @param {string} configStr - 左のセル (通常抽選) のsim-config
         * @param {string} gachaId - 確定枠のガチャID
         * @returns {string|null} - 生成された確定枠のsim-config、またはnull
         */
        function generateGuaranteedConfig(configStr, gachaId) {
            if (!configStr) return null;

            const parsed = parseSimConfig(configStr);
            if (parsed.length === 0) return null;
            
            // リンクは左のセルのパラメータを参照し、最後のロール数を-1して...
            const lastPart = parsed.pop();
            
            // 最後のセグメントが通常ロールであり、かつロール数が1以上であること
            if (!lastPart.g && lastPart.rolls > 0) { 
                
                // 通常抽選のロール数を -1 する
                const newRollsForLastPart = Math.max(0, lastPart.rolls - 1);
                
                // 置き換える部分 (10ロール分) のシミュレーション設定を再追加
                if (newRollsForLastPart > 0) {
                    lastPart.rolls = newRollsForLastPart;
                    parsed.push(lastPart);
                }

                // 続けて当該列のガチャID、11ｇとする
                parsed.push({ id: gachaId, rolls: 11, g: true });
                
                return stringifySimConfig(parsed);
            }
            return null;
        }

        // --- ★ 5. (新規) 回避/誘発ロジック用ヘルパー関数 ---

        /**
         * ★ 修正: i行目のトラック -> seedIndex
         * @param {Map} cellSimConfigs - デフォルトリンクのMap
         * @param {number} seedIndex - 0-based seed index
         * @param {Array} gachaConfigs - ガチャ設定配列
         * @returns {string|null} - 見つかった最初のsim-config文字列、またはnull
         */
        // ★★★ 修正箇所 1 ★★★
        function getBestLink(cellSimConfigs, seedIndex, gachaConfigs) {
            if (seedIndex < 0) return null;
            // ★ 修正: どのガチャのリンクでも良いので最初に見つかったものを返す
            for (const config of gachaConfigs) {
                const configStr = cellSimConfigs.get(`${seedIndex}-${config.id}`);
                // ★ 修正: undefined (キーが存在しない) 以外なら返す (null や '' も有効な値として扱う)
                if (configStr !== undefined) {
                    return configStr;
                }
            }
            return null;
        }

        /**
         * 誘発ロジック用に、強制的に3シード消費した場合のキャラ名を取得する
         * @param {object} currentRoll - tableData[seedIndex][gachaIndex].roll の中身
         * @param {object} gachaConfig - ガチャ設定
         * @returns {string|null} - 再抽選後のキャラ名、またはnull
         */
        function getForcedRerollName(currentRoll, gachaConfig) {
            if (!currentRoll || !gachaConfig || currentRoll.rarity !== 'rare' || currentRoll.s2 === null) {
                return null;
            }
            
            const characterPool = gachaConfig.pool['rare'] || [];
            const uniqueRareChars = characterPool.filter(c => c.id !== currentRoll.originalChar.id);
            const uniqueTotal = uniqueRareChars.length;
            
            if (uniqueTotal > 0) {
                const reRollIndex = currentRoll.s2 % uniqueTotal;
                return uniqueRareChars[reRollIndex].name;
            }
            return null;
        }


        /**
         * ★ 修正: (メインロジック) レア被り回避と誘発の代替リンクを計算する
         * @param {number} seedIndex - 0-based seed index
         * @param {string} currentGachaId - 現在のガチャID
         * @param {Array} tableData - 全テーブルデータ
         * @param {Array} gachaConfigs - ガチャ設定配列
         * @param {Map} cellSimConfigs - デフォルトリンクのMap
         * @param {number} newRow1Index - CONTINUEエリアの開始行
         * @returns {object} - { link: string|null, rerollCharName: string|null }
         */
        function checkAvoidanceAndForcing(seedIndex, currentGachaId, tableData, gachaConfigs, cellSimConfigs, newRow1Index) {
            const i = Math.floor(seedIndex / 2); // 行インデックス
            if (i < newRow1Index) {
                return { link: null, rerollCharName: null };
            }

            const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
            if (gachaIndex === -1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) {
                return { link: null, rerollCharName: null };
            }

            const currentRoll = tableData[seedIndex][gachaIndex].roll;
            const isRerolled = currentRoll.isRerolled;
            const originalCharId = currentRoll.originalChar?.id;
            const originalRarity = currentRoll.rarity;

            if (originalRarity !== 'rare' || !originalCharId) {
                return { link: null, rerollCharName: null };
            }

            // ★ 修正: seedIndex - 2 (同一トラック) と seedIndex - 3 (別トラックからの被り遷移) の両方をチェック
            const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];

            for (const otherConfig of gachaConfigs) {
                const otherGachaId = otherConfig.id;
                if (otherGachaId === currentGachaId) continue; // 別のガチャのみチェック

                const otherIndex = gachaConfigs.findIndex(c => c.id === otherGachaId);
                if (otherIndex === -1) continue;

                // ★★★ 修正箇所 2 ★★★
                const createAltConfig = (prevIndexUsed) => {
                    // リンクの基点を、実際にロールを置き換える前の prevIndexUsed にする
                    const configStr = getBestLink(cellSimConfigs, prevIndexUsed, gachaConfigs); 
                    
                    // ★ 修正: configStr が null (リンク無効 or キー未設定) の場合は null を返す
                    if (configStr === null) return null; 
                    
                    // configStr が '' (起点) または有効な文字列の場合
                    const parts = parseSimConfig(configStr); // '' の場合は []
                    
                    // 最後のセグメントが置き換え対象のガチャIDと同じならロール数を+1、違うなら新しいセグメントを追加
                    const last_part = parts.length > 0 ? parts[parts.length - 1] : null;
                    if (last_part && last_part.id === otherGachaId && !last_part.g) {
                        last_part.rolls += 1;
                    } else {
                        parts.push({ id: otherGachaId, rolls: 1, g: false });
                    }
                    return stringifySimConfig(parts);
                };

                for (const prevIndex of prevIndicesToCheck) {
                    if (prevIndex < 0) continue;

                    const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;
                    if (!otherRoll_prev) continue;

                    if (isRerolled) {
                        // --- 1. レア被り回避 (Avoid Dupe) ---
                        // 別のガチャ(otherRoll_prev)が、被りの原因(originalCharId)と異なるキャラだった場合
                        if (otherRoll_prev.rarity !== 'rare' || otherRoll_prev.charId !== originalCharId) { 
                            const altConfig = createAltConfig(prevIndex);
                            if (altConfig) {
                                return { link: altConfig, rerollCharName: null };
                            }
                        }
                    } else {
                        // --- 2. レア被り誘発 (Force Dupe) ---
                        // 別のガチャ(otherRoll_prev)が、被りの原因(originalCharId)と同じキャラだった場合
                        if (otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                            const altConfig = createAltConfig(prevIndex);
                            if (altConfig) {
                                const rerollCharName = getForcedRerollName(currentRoll, gachaConfigs[gachaIndex]);
                                return { link: altConfig, rerollCharName: rerollCharName };
                            }
                        }
                    }
                }
            }

            return { link: null, rerollCharName: null };
        }

        /** ★ 修正: track, i -> seedIndex */
        function canBeForced(seedIndex, currentGachaId, tableData, gachaConfigs) {
            const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
            if (gachaIndex === -1 || seedIndex < 1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) return false;

            const currentRoll = tableData[seedIndex][gachaIndex].roll;
            // ★ 修正: 2つ前と3つ前のシードをチェック
            const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];

            for (const prevIndex of prevIndicesToCheck) {
                if (prevIndex < 0) continue;
                for (const otherConfig of gachaConfigs) {
                    const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
                    if (otherIndex === -1) continue;

                    const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;

                    if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                        return true;
                    }
                }
            }
            return false;
        }

        /** ★ 修正: track, i -> seedIndex */
        function canBeAvoided(seedIndex, currentGachaId, tableData, gachaConfigs) {
            const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
            if (gachaIndex === -1 || seedIndex < 1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) return false;

            const currentRoll = tableData[seedIndex][gachaIndex].roll;
            if (currentRoll.rarity !== 'rare' || !currentRoll.isRerolled || !currentRoll.originalChar) return false;
            
            const originalCharId = currentRoll.originalChar.id;

            // ★ 修正: 2つ前と3つ前のシードをチェック
            const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];

            for (const prevIndex of prevIndicesToCheck) {
                if (prevIndex < 0) continue;
                for (const otherConfig of gachaConfigs) {
                    const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
                    if (otherIndex === -1) continue;

                    const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;

                    if (otherRoll_prev && (otherRoll_prev.rarity !== 'rare' || otherRoll_prev.charId !== originalCharId)) {
                        return true;
                    }
                }
            }
            return false;
        }

        // --- ヘルパー関数 終了 ---

        // --- ★ 修正: Helper functions for new calculation columns ---
        /**
         * @param {number} serialNumber - 1-based seed index (S1)
         * @param {object} rollResult - The roll result object
         * @param {number[]} seeds - The seeds array (not used here, but kept for consistency)
         */
        function getRarityDetail(serialNumber, rollResult, seeds) {
            if (!rollResult) return '';
            // serialNumber is 1-based (S1).
            const { s0, rarity } = rollResult;
            if (s0 === null || rarity === null) return '';
            return `(S${serialNumber})${s0}<br>${s0 % 10000}<br>${rarity}`;
        }

        /**
         * @param {number} serialNumber - 1-based seed index (S1)
         * @param {object} rollResult - The roll result object
         * @param {number[]} seeds - The seeds array (not used here)
         */
        function getSlotDetail(serialNumber, rollResult, seeds) {
            if (!rollResult) return '';
            // serialNumber is 1-based (S1). S2 is serialNumber + 1.
            const { s1, totalChars, charIndex } = rollResult;
            if (s1 === null || totalChars === 0) return '';
            return `(S${serialNumber + 1})${s1}<br>${totalChars}<br>${charIndex}`;
        }

        /**
         * @param {number} serialNumber - 1-based seed index (S1)
         * @param {object} rollResult - The roll result object
         * @param {object} gachaConfig - The gacha config (not used here)
         * @param {number[]} seeds - The seeds array (not used here)
         */
        function getRerollDetail(serialNumber, rollResult, gachaConfig, seeds) {
            if (rollResult && rollResult.isRerolled) {
                // serialNumber is 1-based (S1). S3 is serialNumber + 2.
                const { s2, uniqueTotal, reRollIndex } = rollResult;
                if (s2 === null) return '---';
                return `(S${serialNumber + 2})${s2}<br>${uniqueTotal}<br>${reRollIndex}`;
            } else {
                return '---';
            }
        }

        /**
         * @param {number} serialNumber - 1-based seed index (S1)
         * @param {object} gachaConfig - The gacha config
         * @param {number[]} seeds - The seeds array
         * @param {object} lastDraw - The last draw info
         */
        function getGuaranteedDetail(serialNumber, gachaConfig, seeds, lastDraw) {
            if (!gachaConfig) return '---';
            const startIndex = serialNumber - 1; // 0-based seed index for S1
            const lookahead = calculateGuaranteedLookahead(startIndex, gachaConfig, seeds, lastDraw);

            if (!lookahead || lookahead.name === "データ不足" || lookahead.name === "N/A" || lookahead.nextRollStartSeedIndex === null) {
                return '---';
            }
            
            const guaranteedSeedIndex = lookahead.nextRollStartSeedIndex - 1; // 0-based index of the guaranteed seed
            if (guaranteedSeedIndex < 0 || guaranteedSeedIndex >= seeds.length) return '---';

            const guaranteedSeed = seeds[guaranteedSeedIndex];
            const uberPool = gachaConfig.pool['uber'] || [];
            const totalUbers = uberPool.length;
            if (totalUbers === 0) return '---';

            const slotIndex = guaranteedSeed % totalUbers;

            // guaranteedSeedIndex は 0-based なので、S(N) 形式で表示するために +1 (serial number) する
            return `(S${guaranteedSeedIndex + 1})${guaranteedSeed}<br>${totalUbers}<br>${slotIndex}`;
        }
        // --- End of helper functions ---



        function getAddress(seedIndex, numRolls) {
            if (seedIndex === null || seedIndex >= numRolls * 2) return '';
            const serialNumber = seedIndex + 1;
            const row = Math.floor(seedIndex / 2) + 1;
            const track = (seedIndex % 2 === 0) ? 'A' : 'B';
            const adrs = `${row}${track}`;
            return `No.${serialNumber}(${adrs})`;
        }

        function getDupeInfoHtml(dupeInfo, seedIndex, numRolls) {
            if (!dupeInfo) return '---';

            const { isDupe, isConsecutive, isForceable, isAvoidable } = dupeInfo;

            // Line 1: （被り）... / （連続）...
            const dupeDest = isDupe ? `→${getAddress(seedIndex + 3, numRolls)}` : '';
            const dupeText = `（被り）${isDupe ? 'True' : 'False'}${dupeDest}`;
            const consecutiveText = `（連続）${isDupe ? (isConsecutive ? 'True' : 'False') : '---'}`;
            const line1 = `${dupeText}/${consecutiveText}`;

            // Line 2: （誘発）... / （回避）...
            let forceableText = '（誘発）---';
            if (!isDupe) {
                if (isForceable) {
                    const forceableDest = `→${getAddress(seedIndex + 3, numRolls)}`;
                    forceableText = `（誘発）True${forceableDest}`;
                } else {
                    forceableText = '（誘発）False';
                }
            }

            let avoidableText = '（回避）---';
            if (isDupe) {
                if (isAvoidable) {
                    const avoidableDest = `→${getAddress(seedIndex + 2, numRolls)}`;
                    avoidableText = `（回避）True${avoidableDest}`;
                } else {
                    avoidableText = '（回避）False';
                }
            }
            
            const line2 = `${forceableText}/${avoidableText}`;

            return `${line1}<br>${line2}`;
        }


        function generateRollsTable() {
            try {
                if (Object.keys(gachaMasterData).length === 0) { return; }
                const initialSeed = parseInt(document.getElementById('seed').value, 10);
                const numRolls = currentRolls; // numRolls は行数 (A/Bペアの数)
                if (isNaN(initialSeed) || isNaN(numRolls)) {
                    document.getElementById('rolls-table-container').innerHTML = '<p class="error">エラー: 有効な値を入力してください。</p>';
                    return;
                }
                
                const seeds = [];
                const rngForSeeds = new Xorshift32(initialSeed);
                // ★ 修正: numRolls * 2 (シード数) を基準に十分なシードを生成
                for (let i = 0; i < numRolls * 15 + 20; i++) { seeds.push(rngForSeeds.next()); } // Increased seed generation

                const simConfigInput = document.getElementById('sim-config').value.trim();
                let simConfigs = [];
                
                if (simConfigInput) {
                    simConfigs = parseSimConfig(simConfigInput);
                    simConfigs.forEach(sim => {
                        if (gachaMasterData.gachas[sim.id]) {
                            sim.gachaConfig = gachaMasterData.gachas[sim.id];
                        }
                        const gachaIdInTable = sim.g ? `${sim.id}g` : sim.id;
                        const hasGuaranteed = tableGachaIds.includes(`${sim.id}g`);
                        if (!tableGachaIds.includes(gachaIdInTable)) {
                            if (sim.g) {
                                tableGachaIds.push(gachaIdInTable);
                            } else {
                                if (!hasGuaranteed) {
                                    tableGachaIds.push(gachaIdInTable);
                                }
                            }
                        }
                    });
                }
                
                // ★ 修正: gachaConfigs は G列を含まないユニークIDのリスト
                const uniqueGachaIds = [...new Set(tableGachaIds.map(id => id.replace('g', '')))];
                const gachaConfigs = uniqueGachaIds.map(id => gachaMasterData.gachas[id]).filter(Boolean);
                gachaConfigsForRevert = gachaConfigs; // ★ グローバル変数にセット

                // ★ 修正: highlightMap, pathDetails を seedIndex (0-based) 基準に変更
                const highlightMap = new Map();
                const simulationResults = [];
                
                let rngForText = new Xorshift32(initialSeed);
                let currentSeedIndex = 0; // 0-based seed index
                let lastDrawForHighlight = { rarity: null, charId: null };
                let pathDetails = []; // { seedIndex: number, id: string }
                let totalSimRolls = 0;

                if (simConfigs.length > 0) {
                    for (const sim of simConfigs) {
                        if (!sim.gachaConfig) continue; 
                        const isGuaranteedPath = sim.g && sim.rolls === 11;
                        
                        if (isGuaranteedPath) {
                            const startSeedIndex = currentSeedIndex;
                            for (let i = 0; i < 10; i++) {
                                // ★ 修正: currentSeedIndex が numRolls*2 を超えないように
                                if (currentSeedIndex >= numRolls * 2) break; 
                                highlightMap.set(currentSeedIndex, sim.id);
                                const rollResult = rollWithSeedConsumptionFixed(currentSeedIndex, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;
                                pathDetails.push({ seedIndex: currentSeedIndex, id: sim.id });
                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                currentSeedIndex += rollResult.seedsConsumed;
                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                simulationResults.push({ ...sim, result: rollResult, track: (pathDetails[pathDetails.length-1].seedIndex % 2 === 0 ? 'A' : 'B'), isGuaranteed: false, rollNum: ++totalSimRolls });
                            }
                            // ★ 修正: Gハイライトキー
                            if (startSeedIndex < numRolls * 2) {
                                highlightMap.set(`${startSeedIndex}G`, sim.id); 
                            }
                            if (currentSeedIndex >= seeds.length) continue;
                            const guaranteedResult = rollGuaranteedUber(currentSeedIndex, sim.gachaConfig, seeds);
                            currentSeedIndex += guaranteedResult.seedsConsumed;
                            for(let k = 0; k < guaranteedResult.seedsConsumed; k++) rngForText.next(); 
                            simulationResults.push({ ...sim, result: guaranteedResult, track: (startSeedIndex % 2 === 0 ? 'A' : 'B'), isGuaranteed: true, rollNum: ++totalSimRolls });
                        } else {
                            for (let i = 0; i < sim.rolls; i++) {
                                if (currentSeedIndex >= numRolls * 2) break;
                                highlightMap.set(currentSeedIndex, sim.id);
                                const rollResult = rollWithSeedConsumptionFixed(currentSeedIndex, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;
                                pathDetails.push({ seedIndex: currentSeedIndex, id: sim.id });
                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                currentSeedIndex += rollResult.seedsConsumed;
                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                simulationResults.push({ ...sim, result: rollResult, track: (pathDetails[pathDetails.length-1].seedIndex % 2 === 0 ? 'A' : 'B'), isGuaranteed: false, rollNum: ++totalSimRolls });
                            }
                        }
                    }
                }
                finalSeedForUpdate = rngForText.seed;
                
                // ★ 修正: tableData を seedIndex (0-based) 基準に変更
                const tableData = Array(numRolls * 2).fill(null).map(() => []);
                
                gachaConfigs.forEach((config, gachaIndex) => {
                    if (!config) return;
                    // ★ 修正: prevDrawA, prevDrawB をガチャごとに管理
                    let prevDrawA = null; // Aトラック (偶数 index) の直前の描画
                    let prevDrawB = null; // Bトラック (奇数 index) の直前の描画
                    
                    for (let i = 0; i < numRolls; i++) { // i は行インデックス
                        const seedIndexA = i * 2;
                        const seedIndexB = i * 2 + 1;

                        const wasPrevDrawARerolled = prevDrawA ? prevDrawA.isRerolled : false;
                        const rollResultA = rollWithSeedConsumptionFixed(seedIndexA, config, seeds, prevDrawA);
                        const isConsecutiveA = wasPrevDrawARerolled && rollResultA.isRerolled;
                        tableData[seedIndexA][gachaIndex] = { gachaId: config.id, roll: rollResultA, isConsecutive: isConsecutiveA };
                        prevDrawA = { rarity: rollResultA.rarity, charId: rollResultA.charId, isRerolled: rollResultA.isRerolled };
                        
                        if (seedIndexB >= seeds.length - 2) break; // Bトラックのデータがなければ終了

                        const wasPrevDrawBRerolled = prevDrawB ? prevDrawB.isRerolled : false;
                        const rollResultB = rollWithSeedConsumptionFixed(seedIndexB, config, seeds, prevDrawB);
                        const isConsecutiveB = wasPrevDrawBRerolled && rollResultB.isRerolled;
                        tableData[seedIndexB][gachaIndex] = { gachaId: config.id, roll: rollResultB, isConsecutive: isConsecutiveB };
                        prevDrawB = { rarity: rollResultB.rarity, charId: rollResultB.charId, isRerolled: rollResultB.isRerolled };
                        
                        if (seedIndexB + 2 >= seeds.length - 2) break;
                    }
                });

                // --- ★ 修正: Calculation Details Generation (全ガチャ対応) ---
                const details = {}; 

                if (showSeedColumns) {
                    gachaConfigs.forEach((gachaConfig, gachaIndex) => {
                        if (!gachaConfig) return;
                        const gachaId = gachaConfig.id;
                        details[gachaId] = { rarity: [], slot: [], reroll: [], guaranteed: [], dupeInfo: [] };
                        
                        let lastDrawA = null;
                        let lastDrawB = null;

                        for (let i = 0; i < numRolls; i++) {
                            const serialNumberA = i * 2 + 1;
                            const seedIndexA = i * 2;
                            const rollA = tableData[seedIndexA]?.[gachaIndex]?.roll;
                            
                            if (rollA && rollA.s0 !== null) {
                                details[gachaId].rarity[seedIndexA] = getRarityDetail(serialNumberA, rollA, seeds);
                                details[gachaId].slot[seedIndexA] = getSlotDetail(serialNumberA, rollA, seeds);
                                details[gachaId].reroll[seedIndexA] = getRerollDetail(serialNumberA, rollA, gachaConfig, seeds);
                                details[gachaId].guaranteed[seedIndexA] = getGuaranteedDetail(serialNumberA, gachaConfig, seeds, lastDrawA);
                                const isDupeA = rollA.isRerolled;
                                const isConsecutiveA = tableData[seedIndexA]?.[gachaIndex]?.isConsecutive;
                                const isForceableA = canBeForced(seedIndexA, gachaId, tableData, gachaConfigs);
                                const isAvoidableA = canBeAvoided(seedIndexA, gachaId, tableData, gachaConfigs);
                                details[gachaId].dupeInfo[seedIndexA] = { isDupe: isDupeA, isConsecutive: isConsecutiveA, isForceable: isForceableA, isAvoidable: isAvoidableA };
                                lastDrawA = { rarity: rollA.rarity, charId: rollA.charId };
                            }

                            const serialNumberB = i * 2 + 2;
                            const seedIndexB = i * 2 + 1;
                            const rollB = tableData[seedIndexB]?.[gachaIndex]?.roll;

                            if (rollB && rollB.s0 !== null) {
                                details[gachaId].rarity[seedIndexB] = getRarityDetail(serialNumberB, rollB, seeds);
                                details[gachaId].slot[seedIndexB] = getSlotDetail(serialNumberB, rollB, seeds);
                                details[gachaId].reroll[seedIndexB] = getRerollDetail(serialNumberB, rollB, gachaConfig, seeds);
                                details[gachaId].guaranteed[seedIndexB] = getGuaranteedDetail(serialNumberB, gachaConfig, seeds, lastDrawB);
                                const isDupeB = rollB.isRerolled;
                                const isConsecutiveB = tableData[seedIndexB]?.[gachaIndex]?.isConsecutive;
                                const isForceableB = canBeForced(seedIndexB, gachaId, tableData, gachaConfigs);
                                const isAvoidableB = canBeAvoided(seedIndexB, gachaId, tableData, gachaConfigs);
                                details[gachaId].dupeInfo[seedIndexB] = { isDupe: isDupeB, isConsecutive: isConsecutiveB, isForceable: isForceableB, isAvoidable: isAvoidableB };
                                lastDrawB = { rarity: rollB.rarity, charId: rollB.charId };
                            }
                        }
                    });
                }
                gachaDetailsForAllGachas = details; // ★ グローバル変数にセット
                // --- End of Calculation Details ---

                // ★ 修正: cellSimConfigs を seedIndex (0-based) 基準に変更
                const cellSimConfigs = new Map();
                const cellSimConfigs_Alt = new Map();
                
                let startSeedIndex = currentSeedIndex; // 0-based
                let newRow1Index = Math.floor(startSeedIndex / 2); 
                let startTrack = (startSeedIndex % 2 === 0) ? 'A' : 'B';
                let baseConfig = simConfigInput;

                if (simConfigInput === '') {
                    newRow1Index = 0;
                    startTrack = 'A';
                }
                
                // ★ 修正: pathDetails (ハイライト部分) の sim-config を設定
                if (pathDetails.length > 0) {
                    const lastStep = pathDetails[pathDetails.length - 1];
                    let lastHighlightedConfig = simConfigInput;
                    if (simConfigInput.endsWith('g')) {
                        const parsed = parseSimConfig(simConfigInput);
                        const lastPart = parsed.pop();
                        if (lastPart && lastPart.g && lastPart.rolls === 11) {
                            lastPart.rolls = 10;
                            lastPart.g = false;
                            parsed.push(lastPart);
                            lastHighlightedConfig = stringifySimConfig(parsed);
                        }
                    }
                    cellSimConfigs.set(`${lastStep.seedIndex}-${lastStep.id}`, lastHighlightedConfig);
                    
                    for (let i = pathDetails.length - 2; i >= 0; i--) {
                        const currentStep = pathDetails[i];
                        const nextStep = pathDetails[i + 1];
                        const nextConfigStr = cellSimConfigs.get(`${nextStep.seedIndex}-${nextStep.id}`);
                        const currentConfigStr = decrementLastRollOrRemoveSegment(nextConfigStr);
                        cellSimConfigs.set(`${currentStep.seedIndex}-${currentStep.id}`, currentConfigStr);
                    }
                    
                    gachaConfigs.forEach(config => {
                        pathDetails.forEach(step => {
                            if (config.id === step.id) return;
                            const seedIndex = step.seedIndex;
                            const cellKey = `${seedIndex}-${config.id}`;
                            const primaryCellKey = `${seedIndex}-${step.id}`;
                            const primaryConfigStr = cellSimConfigs.get(primaryCellKey);
                            if (primaryConfigStr === '' || primaryConfigStr === null || typeof primaryConfigStr === 'undefined') {
                                cellSimConfigs.set(cellKey, null);
                            } else {
                                let newConfig = parseSimConfig(primaryConfigStr);
                                if (newConfig.length > 0) {
                                    newConfig[newConfig.length - 1].id = config.id;
                                    cellSimConfigs.set(cellKey, stringifySimConfig(newConfig));
                                } else {
                                    cellSimConfigs.set(cellKey, null);
                                }
                            }
                        });
                    });
                    
                    // ★ 修正: トラックロックのロジックを seedIndex ベースに変更
                    const tracksInPath = [...new Set(pathDetails.map(step => step.seedIndex % 2))]; // 0 (A) or 1 (B)
                    if (tracksInPath.length === 1) {
                        const primaryTrackIndex = tracksInPath[0];
                        const highlightedSeedIndices = new Set(pathDetails.map(step => step.seedIndex));
                        
                        highlightedSeedIndices.forEach(seedIndex => {
                            const trackIndex = seedIndex % 2;
                            if (trackIndex === primaryTrackIndex) {
                                const oppositeSeedIndex = (primaryTrackIndex === 0) ? seedIndex + 1 : seedIndex - 1;
                                if (oppositeSeedIndex >= 0 && oppositeSeedIndex < numRolls * 2) {
                                     gachaConfigs.forEach(config => {
                                         cellSimConfigs.set(`${oppositeSeedIndex}-${config.id}`, null);
                                     });
                                }
                            }
                        });
                    }
                }

                // ★ 新しいリンク生成ロジック
                const startSeedIndexForContinue = newRow1Index * 2 + (startTrack === 'A' ? 0 : 1);

                // 1. 「続き」セクションの最初のリンクを初期設定
                for (const config of gachaConfigs) {
                    const id = config.id;
                    const key = `${startSeedIndexForContinue}-${id}`;
                    if (!cellSimConfigs.has(key)) {
                        const configLink = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                        cellSimConfigs.set(key, configLink);
                    }
                }

                const potentialLinks = new Map(); 

                const setPotentialLink = (targetSeedIndex, id, link, priority) => {
                    if (!link || targetSeedIndex >= numRolls * 2) return;
                    const key = `${targetSeedIndex}-${id}`;
                    const existing = potentialLinks.get(key);
                    if (!existing || priority < existing.priority) {
                        potentialLinks.set(key, { link, priority });
                    }
                };

                // 2. リンクを繰り返し構築して、すべてのセルのリンクを決定する
                for (let i = 0; i < numRolls * 2; i++) { // 十分な回数繰り返して伝播させる
                    let changed = false;
                    for (let seedIndex = startSeedIndexForContinue; seedIndex < numRolls * 2; seedIndex++) {
                        gachaConfigs.forEach(config => {
                            const id = config.id;
                            const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                            if (gachaIndex === -1) return;

                            const configStr = cellSimConfigs.get(`${seedIndex}-${id}`);
                            if (!configStr) return;

                            const roll = tableData[seedIndex]?.[gachaIndex]?.roll;
                            if (!roll) return;
                            
                            const altData = cellSimConfigs_Alt.get(`${seedIndex}-${id}`);
                            const altConfigStr = altData ? altData.link : null;

                            // 4つの優先度パスを評価
                            if (roll.isRerolled) { // 被りあり
                                setPotentialLink(seedIndex + 3, id, incrementLastRoll(configStr), 2); // P2
                                if (altConfigStr) setPotentialLink(seedIndex + 2, id, incrementLastRoll(altConfigStr), 3); // P3
                            } else { // 被りなし
                                setPotentialLink(seedIndex + 2, id, incrementLastRoll(configStr), 1); // P1
                                if (altConfigStr) setPotentialLink(seedIndex + 3, id, incrementLastRoll(altConfigStr), 4); // P4
                            }
                        });
                    }

                    potentialLinks.forEach(({ link }, key) => {
                        if (cellSimConfigs.get(key) !== link) {
                            cellSimConfigs.set(key, link);
                            changed = true;
                        }
                    });

                    if (i > 0 && !changed) break; // 変更がなくなったらループを抜ける
                }
                
                // ★ 修正: リンクの伝播を確実にするための追加パス
                for (let seedIndex = startSeedIndexForContinue; seedIndex < numRolls * 2; seedIndex++) {
                    let baseLinkForCell = null;
                    let baseId = null;
                    // Find a base link in the current cell
                    for (const config of gachaConfigs) {
                        const link = cellSimConfigs.get(`${seedIndex}-${config.id}`);
                        if (link) {
                            baseLinkForCell = link;
                            baseId = config.id;
                            break;
                        }
                    }

                    if (baseLinkForCell) {
                        // Propagate this link to other gachas in the same cell
                        const parts = parseSimConfig(baseLinkForCell);
                        if (parts.length > 0) {
                            const lastPart = parts[parts.length - 1];
                            for (const otherConfig of gachaConfigs) {
                                if (otherConfig.id === baseId) continue;
                                const otherKey = `${seedIndex}-${otherConfig.id}`;
                                if (!cellSimConfigs.has(otherKey)) {
                                    lastPart.id = otherConfig.id;
                                    cellSimConfigs.set(otherKey, stringifySimConfig(parts));
                                }
                            }
                            // Restore original id to lastPart
                            lastPart.id = baseId;
                        }
                    }
                }


                // ★ 2nd Pass: Populate cellSimConfigs_Alt for avoidable/forceable links
                for (let seedIndex = startSeedIndexForContinue; seedIndex < numRolls * 2; seedIndex++) {
                    gachaConfigs.forEach(config => {
                        const id = config.id;
                        // Now that cellSimConfigs is final, we can reliably check for alternatives
                        const altData = checkAvoidanceAndForcing(seedIndex, id, tableData, gachaConfigs, cellSimConfigs, newRow1Index);
                        if (altData.link) { 
                            cellSimConfigs_Alt.set(`${seedIndex}-${id}`, altData); 
                        }
                    });
                }



                const buttonHtml = `<button class="add-gacha-btn" onclick="addGachaColumn()">＋列を追加</button>`;
                let totalGachaCols = 0;
                // ★ 修正: tableGachaIds (Gあり) を使う
                tableGachaIds.forEach(idWithG => {
                    const id = idWithG.replace('g', '');
                    if (gachaMasterData.gachas[id]) {
                        totalGachaCols += idWithG.endsWith('g') ? 2 : 1;
                    }
                });
                
                const calcColClass = `calc-column ${showSeedColumns ? '' : 'hidden'}`;
                const calcColSpan = showSeedColumns ? 5 : 0;
                const totalTrackSpan = calcColSpan + totalGachaCols;

                let tableHtml = `<table><thead>
                    <tr>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th colspan="${totalTrackSpan}">A ${buttonHtml}</th>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th colspan="${totalTrackSpan}">B</th>
                    </tr>
                    <tr>`;
                
                // A Track Headers
                tableHtml += `
                    <th class="${calcColClass}">S1<br>rarity</th>
                    <th class="${calcColClass}">S2<br>slot</th>
                    <th class="${calcColClass}">S3<br>ReRoll</th>
                    <th class="${calcColClass}">Guaranteed<br>slot</th>
                    <th class="${calcColClass}">被り/連続被り※（遷移先）<br>誘発/回避可否（遷移先）</th>
                `;
                // ★ 修正: tableGachaIds (Gあり) を使う
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;
                    const removeButtonHtml = `<button onclick="removeGachaColumn(${index})">x</button>`;
                    const gButtonHtml = `<button onclick="toggleGuaranteedColumn(${index})">G</button>`;
                    let selectorHtml = `<select onchange="updateGachaSelection(this, ${index})">`;
                    Object.values(gachaMasterData.gachas).filter(g => g.sort < 800).sort((a, b) => a.sort - b.sort).forEach(gacha => {
                        selectorHtml += `<option value="${gacha.id}" ${gacha.id === id ? 'selected' : ''}>${gacha.name}</option>`;
                    });
                    selectorHtml += '</select>';
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;
                    const headerClass = isGuaranteed ? '' : 'class="gacha-column"';
                    tableHtml += `<th ${headerClass} ${isGuaranteed ? ' colspan="2"' : ''}><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                });

                // B Track Headers
                tableHtml += `
                    <th class="${calcColClass}">S1<br>rarity</th>
                    <th class="${calcColClass}">S2<br>slot</th>
                    <th class="${calcColClass}">S3<br>ReRoll</th>
                    <th class="${calcColClass}">Guaranteed<br>slot</th>
                    <th class="${calcColClass}">被り/連続被り※（遷移先）<br>誘発/回避可否（遷移先）</th>
                `;
                // ★ 修正: tableGachaIds (Gあり) を使う
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;
                    const headerClass = isGuaranteed ? '' : 'class="gacha-column"';
                    tableHtml += `<th ${headerClass} ${isGuaranteed ? ' colspan="2"' : ''}>${headerName}</th>`;
                });

                tableHtml += `</tr></thead><tbody>`;

                /**
                 * ★ 修正: G列(確定枠)を *含まない* 通常セルを生成する
                 * @param {number} seedIndex - 0-based seed index
                 * @param {string} id - gacha ID
                 */
                function generateCellContent(seedIndex, id) {
                    const i = Math.floor(seedIndex / 2); // row index
                    const track = (seedIndex % 2 === 0) ? 'A' : 'B';
                    
                    const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                    if (gachaIndex === -1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex] || !tableData[seedIndex][gachaIndex].roll) {
                        const eventHandlers = `onmouseover="updateCalcColumns(${seedIndex}, '${id}')" onmouseout="revertCalcColumns(${seedIndex})"`;
                        return `<td class="gacha-cell gacha-column" ${eventHandlers}>N/A</td>`;
                    }
                    
                    const fullRoll = tableData[seedIndex][gachaIndex].roll;
                    const configStr = cellSimConfigs.get(`${seedIndex}-${id}`);
                    const altData = cellSimConfigs_Alt.get(`${seedIndex}-${id}`) || { link: null, rerollCharName: null };
                    const altConfigStr = altData.link;
                    
                    let highlightClass = (highlightMap.get(seedIndex) === id) ? ' highlight' : '';
                    if (highlightClass && fullRoll.rarity === 'uber') { highlightClass = ' highlight-uber'; } 
                    
                    let cellStyle = '';
                    if (!highlightClass) {
                        const seedVal = seeds[seedIndex] % 10000;
                        if (seedVal >= 9970) { cellStyle = 'background-color: #DDA0DD;'; } 
                        else if (seedVal >= 9940) { cellStyle = 'background-color: #9370DB;'; } 
                        else if (seedVal >= 9470) { cellStyle = 'background-color: #FF4C4C;'; } 
                        else if (seedVal >= 9070) { cellStyle = 'background-color: #FFB6C1;'; } 
                        else if (seedVal >= 6970) { cellStyle = 'background-color: #FFDAB9;'; } 
                        else if (seedVal >= 6470) { cellStyle = 'background-color: #FFFFE0;'; } 
                    }
                    
                    let cellContent = '';
                    let nextAddress = null;
                    if (fullRoll.seedsConsumed === 3) {
                        // 3シード消費した場合の遷移先 (seedIndex + 3)
                        const destSeedIndex = seedIndex + 3;
                        const destRow = Math.floor(destSeedIndex / 2);
                        const destTrack = (destSeedIndex % 2 === 0) ? 'A' : 'B';
                        if (destRow < numRolls) { nextAddress = `${destRow + 1}${destTrack}`; }
                    } 
                    let addressPrefix = nextAddress ? `${nextAddress}) ` : '';
                    
                    if (fullRoll.isRerolled) {
                        const originalCharName = fullRoll.originalChar.name;
                        const rerollCharName = fullRoll.finalChar.name;
                        let originalDisplay = originalCharName;
                        let rerollDisplay = rerollCharName;
                        if (configStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = ${JSON.stringify(configStr)}; resetAndGenerateTable();`;
                            rerollDisplay = `<a href="${href}" onclick="${onclickAction}">${addressPrefix}${rerollCharName}</a>`;
                        } else {
                            rerollDisplay = `${addressPrefix}${rerollCharName}`;
                        }
                        if (altConfigStr) {
                            // 回避リンク (2シード消費) の遷移先
                            const avoidDestSeedIndex = seedIndex + 2;
                            const avoidDestRow = Math.floor(avoidDestSeedIndex / 2);
                            const avoidDestTrack = (avoidDestSeedIndex % 2 === 0) ? 'A' : 'B';
                            const avoidAddress = (avoidDestRow < numRolls) ? `${avoidDestRow + 1}${avoidDestTrack}) ` : '';

                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(altConfigStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = ${JSON.stringify(altConfigStr)}; resetAndGenerateTable();`;
                            originalDisplay = `<a href="${href}" onclick="${onclickAction}">${avoidAddress}${originalCharName}</a>`;
                        }
                        cellContent = `${originalDisplay}<br>${rerollDisplay}`;
                    } else {
                        // 通常 (2シード消費)
                        const destSeedIndex = seedIndex + 2;
                        const destRow = Math.floor(destSeedIndex / 2);
                        const destTrack = (destSeedIndex % 2 === 0) ? 'A' : 'B';
                        const normalAddress = (destRow < numRolls) ? `${destRow + 1}${destTrack}) ` : '';

                        const originalCharName = fullRoll.finalChar.name;
                        let originalDisplay = originalCharName;
                        if (configStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = ${JSON.stringify(configStr)}; resetAndGenerateTable();`;
                            originalDisplay = `<a href="${href}" onclick="${onclickAction}">${normalAddress}${originalCharName}</a>`;
                        } else {
                            originalDisplay = `${normalAddress}${originalCharName}`;
                        }
                        cellContent = originalDisplay;

                        if (altConfigStr) {
                            // 誘発リンク (3シード消費) の遷移先 (addressPrefix と同じ)
                            const rerollCharName = altData.rerollCharName || "??";
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(altConfigStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = ${JSON.stringify(altConfigStr)}; resetAndGenerateTable();`;
                            const rerollDisplay = `<a href="${href}" onclick="${onclickAction}">${addressPrefix}${rerollCharName}</a>`;
                            cellContent = `${originalDisplay}<br>${rerollDisplay}`;
                        }
                    }
                    const eventHandlers = `onmouseover="updateCalcColumns(${seedIndex}, '${id}')" onmouseout="revertCalcColumns(${seedIndex})"`;
                    return `<td class="gacha-cell gacha-column${highlightClass}" style="${cellStyle}" ${eventHandlers}>${cellContent}</td>`;
                }


                for (let i = 0; i < numRolls; i++) {
                    let no_A_content, no_B_content;
                    
                    const serialNumberA = i * 2 + 1;
                    const serialNumberB = i * 2 + 2;
                    const seedIndexA = i * 2;
                    const seedIndexB = i * 2 + 1;
                        
                    if (showSeedColumns) {
                        const row = i + 1;
                        const cellAddressA = row + 'A';
                        const cellAddressB = row + 'B';
                        no_A_content = `(No)${serialNumberA}<br>(adrs)${cellAddressA}`;
                        no_B_content = `(No)${serialNumberB}<br>(adrs)${cellAddressB}`;
                    } else {
                        no_A_content = i + 1;
                        no_B_content = i + 1;
                    }
                    let rowHtml = `<tr><td class="col-no">${no_A_content}</td>`;
                    
                    // --- Track A Columns ---
                    if (showSeedColumns) {
                        const firstGachaId = gachaConfigs.length > 0 ? gachaConfigs[0].id : null;
                        const defaultDetails = firstGachaId ? details[firstGachaId] : null;
                        const dupeInfoA = defaultDetails ? defaultDetails.dupeInfo[seedIndexA] : null;

                        rowHtml += `<td id="rarity-cell-A-${i}" class="${calcColClass}">${defaultDetails?.rarity[seedIndexA] || ''}</td>`;
                        rowHtml += `<td id="slot-cell-A-${i}" class="${calcColClass}">${defaultDetails?.slot[seedIndexA] || ''}</td>`;
                        rowHtml += `<td id="reroll-cell-A-${i}" class="${calcColClass}">${defaultDetails?.reroll[seedIndexA] || ''}</td>`;
                        rowHtml += `<td id="guaranteed-cell-A-${i}" class="${calcColClass}">${defaultDetails?.guaranteed[seedIndexA] || ''}</td>`;
                        rowHtml += `<td id="dupe-info-cell-A-${i}" class="${calcColClass}">${getDupeInfoHtml(dupeInfoA, seedIndexA, numRolls)}</td>`;
                    }
                    
                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteedColumn = idWithG.endsWith('g');
                        const id = isGuaranteedColumn ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return; 
                        rowHtml += generateCellContent(seedIndexA, id);
                        
                        if (isGuaranteedColumn) {
                            let lastDraw = (i > 0 && tableData[seedIndexA - 2]?.[gachaConfigs.findIndex(c => c.id === id)]?.roll) 
                                ? { rarity: tableData[seedIndexA - 2][gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[seedIndexA - 2][gachaConfigs.findIndex(c => c.id === id)].roll.charId } 
                                : null;
                            const { name: guaranteedChar, nextRollStartSeedIndex } = calculateGuaranteedLookahead(seedIndexA, gachaConfig, seeds, lastDraw);
                            let guaranteedHighlight = '';
                            let content = guaranteedChar;
                            let nextAddressG = null;
                            if (nextRollStartSeedIndex !== null && nextRollStartSeedIndex < seeds.length) {
                                const nextRow = Math.floor(nextRollStartSeedIndex / 2);
                                const nextTrack = (nextRollStartSeedIndex % 2 === 0) ? 'A' : 'B';
                                nextAddressG = `${nextRow + 1}${nextTrack}`;
                            }
                            if (highlightMap.get(`${seedIndexA}G`) === id) { guaranteedHighlight = ' class="highlight-uber"'; }
                            const configStrA = cellSimConfigs.get(`${seedIndexA}-${id}`);
                            const configG_A = generateGuaranteedConfig(configStrA, id); 
                            let addressPrefixG = nextAddressG ? `${nextAddressG}) ` : '';
                            if (configG_A) {
                                const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_A)}&gachas=${tableGachaIds.join('-')}`;
                                const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = ${JSON.stringify(configG_A)}; resetAndGenerateTable();`;
                                content = `<a href="${hrefG}" onclick="${onclickActionG}">${addressPrefixG}${guaranteedChar}</a>`;
                            } 
                            if (!content.includes('<a')) { content = `${addressPrefixG}${guaranteedChar}`}
                            rowHtml += `<td class="gacha-column"${guaranteedHighlight}>${content}</td>`;
                        }
                    });

                    rowHtml += `<td class="col-no">${no_B_content}</td>`;

                    // --- Track B Columns ---
                     if (showSeedColumns) {
                        const firstGachaId = gachaConfigs.length > 0 ? gachaConfigs[0].id : null;
                        const defaultDetails = firstGachaId ? details[firstGachaId] : null;
                        const dupeInfoB = defaultDetails ? defaultDetails.dupeInfo[seedIndexB] : null;

                        rowHtml += `<td id="rarity-cell-B-${i}" class="${calcColClass}">${defaultDetails?.rarity[seedIndexB] || ''}</td>`;
                        rowHtml += `<td id="slot-cell-B-${i}" class="${calcColClass}">${defaultDetails?.slot[seedIndexB] || ''}</td>`;
                        rowHtml += `<td id="reroll-cell-B-${i}" class="${calcColClass}">${defaultDetails?.reroll[seedIndexB] || ''}</td>`;
                        rowHtml += `<td id="guaranteed-cell-B-${i}" class="${calcColClass}">${defaultDetails?.guaranteed[seedIndexB] || ''}</td>`;
                        rowHtml += `<td id="dupe-info-cell-B-${i}" class="${calcColClass}">${getDupeInfoHtml(dupeInfoB, seedIndexB, numRolls)}</td>`;
                    }

                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteedColumn = idWithG.endsWith('g');
                        const id = isGuaranteedColumn ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return;
                        rowHtml += generateCellContent(seedIndexB, id);
                        
                        if (isGuaranteedColumn) {
                             let lastDraw = (i > 0 && tableData[seedIndexB - 2]?.[gachaConfigs.findIndex(c => c.id === id)]?.roll) 
                                ? { rarity: tableData[seedIndexB - 2][gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[seedIndexB - 2][gachaConfigs.findIndex(c => c.id === id)].roll.charId } 
                                : null;
                             const { name: guaranteedChar, nextRollStartSeedIndex } = calculateGuaranteedLookahead(seedIndexB, gachaConfig, seeds, lastDraw);
                             let guaranteedHighlight = '';
                             let content = guaranteedChar;
                             let nextAddressG = null;
                             if (nextRollStartSeedIndex !== null && nextRollStartSeedIndex < seeds.length) {
                                const nextRow = Math.floor(nextRollStartSeedIndex / 2);
                                const nextTrack = (nextRollStartSeedIndex % 2 === 0) ? 'A' : 'B';
                                nextAddressG = `${nextRow + 1}${nextTrack}`;
                             }
                             if (highlightMap.get(`${seedIndexB}G`) === id) { guaranteedHighlight = ' class="highlight-uber"'; }
                             const configStrB = cellSimConfigs.get(`${seedIndexB}-${id}`);
                             const configG_B = generateGuaranteedConfig(configStrB, id); 
                             let addressPrefixG = nextAddressG ? `${nextAddressG}) ` : '';
                             if (configG_B) {
                                const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_B)}&gachas=${tableGachaIds.join('-')}`;
                                const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = ${JSON.stringify(configG_B)}; resetAndGenerateTable();`;
                                content = `<a href="${hrefG}" onclick="${onclickActionG}">${addressPrefixG}${guaranteedChar}</a>`;
                             }
                             if (!content.includes('<a')) { content = `${addressPrefixG}${guaranteedChar}`}
                             rowHtml += `<td class="gacha-column"${guaranteedHighlight}>${content}</td>`;
                        }
                    });
                    
                    rowHtml += `</tr>`;
                    tableHtml += rowHtml;
                }

                tableHtml += '</tbody></table>';
                document.getElementById('rolls-table-container').innerHTML = tableHtml;

                // --- ★ 修正: シリアルテーブルの生成ロジック ---
                const serialTableContainer = document.getElementById('serial-table-container');
                if (showSeedColumns) {
                    let serialTableHtml = `<h2 style="text-align: center; font-size: 1em; margin-top: 20px;">シリアルテーブル (SEED順) <button class="add-gacha-btn" onclick="addGachaColumn()">＋列を追加</button></h2>`;
                    serialTableHtml += `<table><thead><tr>`;
                    serialTableHtml += `<th class="col-no">NO.</th>`;
                    serialTableHtml += `<th class="${calcColClass}">S1<br>rarity</th>`;
                    serialTableHtml += `<th class="${calcColClass}">S2<br>slot</th>`;
                    serialTableHtml += `<th class="${calcColClass}">S3<br>ReRoll</th>`;
                    serialTableHtml += `<th class="${calcColClass}">Guaranteed<br>slot</th>`;
                    serialTableHtml += `<th class="${calcColClass}">被り/連続被り※（遷移先）<br>誘発/回避可否（遷移先）</th>`;
                    
                    tableGachaIds.forEach((idWithG, index) => {
                        const isGuaranteed = idWithG.endsWith('g');
                        if (isGuaranteed) return; // シリアルテーブルにG列は表示しない

                        const id = idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return;

                        const removeButtonHtml = `<button onclick="removeGachaColumn(${index})">x</button>`;
                        const gButtonHtml = `<button onclick="toggleGuaranteedColumn(${index})">G</button>`;
                        let selectorHtml = `<select onchange="updateGachaSelection(this, ${index})">`;
                        Object.values(gachaMasterData.gachas).filter(g => g.sort < 800).sort((a, b) => a.sort - b.sort).forEach(gacha => {
                            selectorHtml += `<option value="${gacha.id}" ${gacha.id === id ? 'selected' : ''}>${gacha.name}</option>`;
                        });
                        selectorHtml += '</select>';
                        const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;
                        serialTableHtml += `<th class="gacha-column"><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                    });

                    serialTableHtml += '</tr></thead><tbody>';

                    // データ行
                    for (let seedIndex = 0; seedIndex < numRolls * 2; seedIndex++) {
                        const firstGachaId = gachaConfigs.length > 0 ? gachaConfigs[0].id : null;
                        if (!firstGachaId || !details[firstGachaId]?.rarity[seedIndex]) break; 

                        const serialNumber = seedIndex + 1;
                        const row = Math.floor(seedIndex / 2) + 1;
                        const adrs = `${row}${(seedIndex % 2 === 0 ? 'A' : 'B')}`;
                        
                        const no_content = `(No)${serialNumber}<br>(adrs)${adrs}`;
                        serialTableHtml += `<tr><td class="col-no">${no_content}</td>`;
                        
                        const dupeInfo = firstGachaId ? details[firstGachaId]?.dupeInfo[seedIndex] : null;
                        serialTableHtml += `<td id="rarity-cell-S-${seedIndex}" class="${calcColClass}">${firstGachaId ? details[firstGachaId]?.rarity[seedIndex] || '' : ''}</td>`;
                        serialTableHtml += `<td id="slot-cell-S-${seedIndex}" class="${calcColClass}">${firstGachaId ? details[firstGachaId]?.slot[seedIndex] || '' : ''}</td>`;
                        serialTableHtml += `<td id="reroll-cell-S-${seedIndex}" class="${calcColClass}">${firstGachaId ? details[firstGachaId]?.reroll[seedIndex] || '' : ''}</td>`;
                        serialTableHtml += `<td id="guaranteed-cell-S-${seedIndex}" class="${calcColClass}">${firstGachaId ? details[firstGachaId]?.guaranteed[seedIndex] || '' : ''}</td>`;
                        serialTableHtml += `<td id="dupe-info-cell-S-${seedIndex}" class="${calcColClass}">${getDupeInfoHtml(dupeInfo, seedIndex, numRolls)}</td>`;
                        
                        tableGachaIds.forEach(idWithG => {
                            if (idWithG.endsWith('g')) return;
                            serialTableHtml += generateCellContent(seedIndex, idWithG);
                        });
                        serialTableHtml += '</tr>';
                    }

                    serialTableHtml += '</tbody></table>';
                    serialTableContainer.innerHTML = serialTableHtml;
                } else {
                    serialTableContainer.innerHTML = ''; // 非表示の場合はクリア
                }
                // --- ★ 追加ここまで ---


                let simulationOutputString = '--- シミュレーション詳細 ---';
                if (simulationResults.length > 0) {
                    simulationResults.forEach((sim, index) => {
                        if (!sim || !sim.result) return;
                        const result = sim.result;
                        let line;
                        if (sim.isGuaranteed) {
                             line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | uber guaranteed ${result.s0} ${result.finalChar.name} (確定枠のシード)`;
                        } else {
                            line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | ${result.s0}(${result.rarity})${result.rarity}`;
                            if (result.isRerolled) {
                                line += ` ${result.originalChar.name} -> ${result.s2} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            } else {
                                line += `／${result.s1} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            }
                        }
                        simulationOutputString += line + '\n';
                    });
                }
                document.getElementById('result').textContent = simulationOutputString;

                updateUrlParams();
            } catch (e) {
                document.getElementById('rolls-table-container').innerHTML = `<p class="error">テーブルの生成中にエラーが発生しました: ${e.message}</p>`;
                document.getElementById('result').textContent = `エラー: ${e.stack}`; // エラー詳細を表示
                console.error(e);
            }
        }

        window.onload = loadAndProcessData;

        function updateCalcColumns(seedIndex, gachaId) {
            if (!showSeedColumns || !gachaDetailsForAllGachas[gachaId]) return;

            const track = (seedIndex % 2 === 0) ? 'A' : 'B';
            const rowIndex = Math.floor(seedIndex / 2);
            const gachaDetails = gachaDetailsForAllGachas[gachaId];
            const numRolls = currentRolls;

            const rarityCell = document.getElementById(`rarity-cell-${track}-${rowIndex}`) || document.getElementById(`rarity-cell-S-${seedIndex}`);
            if (rarityCell) rarityCell.innerHTML = gachaDetails.rarity[seedIndex] || '';
            
            const slotCell = document.getElementById(`slot-cell-${track}-${rowIndex}`) || document.getElementById(`slot-cell-S-${seedIndex}`);
            if (slotCell) slotCell.innerHTML = gachaDetails.slot[seedIndex] || '';

            const rerollCell = document.getElementById(`reroll-cell-${track}-${rowIndex}`) || document.getElementById(`reroll-cell-S-${seedIndex}`);
            if (rerollCell) rerollCell.innerHTML = gachaDetails.reroll[seedIndex] || '';

            const guaranteedCell = document.getElementById(`guaranteed-cell-${track}-${rowIndex}`) || document.getElementById(`guaranteed-cell-S-${seedIndex}`);
            if (guaranteedCell) guaranteedCell.innerHTML = gachaDetails.guaranteed[seedIndex] || '';

            const dupeInfoCell = document.getElementById(`dupe-info-cell-${track}-${rowIndex}`) || document.getElementById(`dupe-info-cell-S-${seedIndex}`);
            if (dupeInfoCell) {
                const dupeInfo = gachaDetails.dupeInfo[seedIndex];
                dupeInfoCell.innerHTML = getDupeInfoHtml(dupeInfo, seedIndex, numRolls);
            }
        }

        function revertCalcColumns(seedIndex) {
            if (!showSeedColumns || gachaConfigsForRevert.length === 0) return;
            const firstGachaId = gachaConfigsForRevert[0].id;
            updateCalcColumns(seedIndex, firstGachaId);
        }
    </script>
</body>
</html>